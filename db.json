{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"source/images/BuildTrigger.png","path":"images/BuildTrigger.png","modified":1,"renderable":0},{"_id":"source/images/LKImageKit_architecture.jpg","path":"images/LKImageKit_architecture.jpg","modified":1,"renderable":0},{"_id":"source/images/sourceManager.png","path":"images/sourceManager.png","modified":1,"renderable":0},{"_id":"source/images/Advanced Xcode build options.png","path":"images/Advanced Xcode build options.png","modified":1,"renderable":0},{"_id":"source/images/BuildEnv.png","path":"images/BuildEnv.png","modified":1,"renderable":0},{"_id":"source/images/LKImageKit_flow.png","path":"images/LKImageKit_flow.png","modified":1,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1}],"Cache":[{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1565789463119},{"_id":"themes/apollo/_config.yml","hash":"2ef54de30f96194c4f14f580ac3910d7ef6cbba0","modified":1565789463120},{"_id":"themes/apollo/README.md","hash":"fb6fbe42172a35cbdaa540a777cc4bc02add2278","modified":1565789463119},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1565789463120},{"_id":"themes/apollo/package.json","hash":"4d13f5f859db7d008f49251543a8f610b2ecabd5","modified":1565789463124},{"_id":"source/_posts/Hexo-利用Github管理你的博客.md","hash":"1fbf7036a98ef32c417215f9c024951ddb38f251","modified":1565789463111},{"_id":"source/_posts/LKImageKit-简述.md","hash":"c627dcc449c1a5d4f4fd79e2eadc180748e0166e","modified":1565790917888},{"_id":"source/_posts/git-flow.md","hash":"000cb8dbcd44faafb515d1fae3a099e1f6d04c0a","modified":1565789463112},{"_id":"source/_posts/新Mac-记一次修改shadowsocks过程.md","hash":"daf54578ac246214050767aeb0b2fb782207e3d0","modified":1565789463112},{"_id":"source/_posts/配置Jenkins-for-iOS-记录一些问题点.md","hash":"065bba6b2f6a081cd6f01d07e3d0754d6e9c74ce","modified":1565789463113},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1565789463120},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1565789463120},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1565789463121},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1565789463121},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1565789463121},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1565789463122},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1565789463124},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1565789463125},{"_id":"source/images/BuildTrigger.png","hash":"c8bcdd0ab480f5c011f8ac0aefc8597999933953","modified":1565789463116},{"_id":"source/images/LKImageKit_architecture.jpg","hash":"f8e149049130b550a397a6751c7b59cd26cd018b","modified":1565790813052},{"_id":"source/images/sourceManager.png","hash":"a1a99f463d4cbe903653b6b56b93744db5bb21b0","modified":1565789463117},{"_id":"source/images/Advanced Xcode build options.png","hash":"5216931702228f9f52b2b67cf0ff80eed7243213","modified":1565789463114},{"_id":"source/images/BuildEnv.png","hash":"f8134ffbec9d0c385224f41b55a7a0f2c3e32de7","modified":1565789463115},{"_id":"source/images/LKImageKit_flow.png","hash":"5a7d84f6a73e355cfc385e9ccae0fa1035e6ecbd","modified":1526030527000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1565789463122},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"cd9447e9b0ad22213e6a17d9a9b948f9f998f921","modified":1565789463122},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1565789463123},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1565789463123},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"eb15573ff66bdbb110ac77cf360b740170cee738","modified":1565789463124},{"_id":"themes/apollo/layout/partial/head.jade","hash":"d062dafabfe65198e5cf2ddb0e47d909885aa950","modified":1565789463123},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"c35d3061da4b053b73150d9741c542d660798270","modified":1565789463124},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"cf3339de8979b5f75a3011f0f6b5451091b77dc8","modified":1565789463124},{"_id":"themes/apollo/source/css/apollo.css","hash":"2cfd049bcbad8a9a68c13299a92e993d5c92d029","modified":1565789463125},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1565789463126},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1565789463126},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1565789463128},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"fe20c16c18ab76b843d0aab2e1a5cc4f5d6d64c7","modified":1565789463127},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1565789463127},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1565789463127},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1565789463128},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1565789463128},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1565789463128},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1565789463127},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1565789463128},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"ae780828148f79e5069b480e3576f1fea1246866","modified":1565789463128},{"_id":"public/atom.xml","hash":"b89312cdc089a72378cc830cf09c124c462b5d86","modified":1565790954609},{"_id":"public/sitemap.xml","hash":"39d502b079ca13e71337dba72ce00fb6bffa6988","modified":1565790954611},{"_id":"public/2019/08/14/LKImageKit-简述/index.html","hash":"d65bf1776dac969214fc6e7b24e7234af9ef8964","modified":1565790954614},{"_id":"public/2018/05/25/git-flow/index.html","hash":"f1ad9d3e33a23cfdd1125feab1f44763c67f4192","modified":1565790954614},{"_id":"public/2016/09/26/配置Jenkins-for-iOS-记录一些问题点/index.html","hash":"8862d0265b640b672e5c230adafc82fc0e804391","modified":1565790954614},{"_id":"public/2016/08/26/Hexo-利用Github管理你的博客/index.html","hash":"76ac7d76f76edabaf9b5548facdbe5b1ebbe6e9a","modified":1565790954614},{"_id":"public/2016/08/25/新Mac-记一次修改shadowsocks过程/index.html","hash":"d8273e54ef20370295c7267d15073b82e82a443b","modified":1565790954615},{"_id":"public/archives/index.html","hash":"46df48ad8f6d0bddfb4585c7d63d48700643e279","modified":1565790954615},{"_id":"public/archives/2016/index.html","hash":"179600db161f6e055491d239764a59230810483f","modified":1565790954615},{"_id":"public/archives/2016/08/index.html","hash":"2d315f239729d86662253936b96d01701554660a","modified":1565790954615},{"_id":"public/archives/2016/09/index.html","hash":"ef74d0bd2e5b47fb284360e6ab4e845c167ae3bb","modified":1565790954615},{"_id":"public/archives/2018/index.html","hash":"e71ce5e5706aa3c12ede14c2ca9af06d048aa204","modified":1565790954615},{"_id":"public/archives/2018/05/index.html","hash":"e71ce5e5706aa3c12ede14c2ca9af06d048aa204","modified":1565790954615},{"_id":"public/archives/2019/index.html","hash":"32f1ec729a39df655781a2bf688d10720b699601","modified":1565790954615},{"_id":"public/archives/2019/08/index.html","hash":"32f1ec729a39df655781a2bf688d10720b699601","modified":1565790954615},{"_id":"public/index.html","hash":"21d092ae1a9d4f6d0a8072b177dae10d32d7ab3a","modified":1565790954616},{"_id":"public/tags/Hexo/index.html","hash":"90b2bc23ecee301fb89d88fe0cab10932988f1ef","modified":1565790954616},{"_id":"public/tags/shadowsocks/index.html","hash":"955f01695632bbd6c336056285bfe29600cc3dc1","modified":1565790954616},{"_id":"public/tags/Jenkins/index.html","hash":"ef74d0bd2e5b47fb284360e6ab4e845c167ae3bb","modified":1565790954616},{"_id":"public/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1565790954622},{"_id":"public/scss/apollo.scss","hash":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1565790954622},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1565790954622},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1565790954622},{"_id":"public/images/LKImageKit_architecture.jpg","hash":"f8e149049130b550a397a6751c7b59cd26cd018b","modified":1565790954627},{"_id":"public/images/BuildTrigger.png","hash":"c8bcdd0ab480f5c011f8ac0aefc8597999933953","modified":1565790954627},{"_id":"public/images/sourceManager.png","hash":"a1a99f463d4cbe903653b6b56b93744db5bb21b0","modified":1565790954628},{"_id":"public/css/apollo.css","hash":"2cfd049bcbad8a9a68c13299a92e993d5c92d029","modified":1565790954631},{"_id":"public/images/Advanced Xcode build options.png","hash":"5216931702228f9f52b2b67cf0ff80eed7243213","modified":1565790954631},{"_id":"public/images/BuildEnv.png","hash":"f8134ffbec9d0c385224f41b55a7a0f2c3e32de7","modified":1565790954631},{"_id":"public/images/LKImageKit_flow.png","hash":"5a7d84f6a73e355cfc385e9ccae0fa1035e6ecbd","modified":1565790954631}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hexo 利用Github管理博客","date":"2016-08-26T10:49:55.000Z","_content":"\n# Hexo 利用Github管理博客\n\n\n### 1 搭建流程\n\n>配置环境\n安装homebrew node.js git \n申请Github\n算了这些就不写了。。。\n\n\n1. 在github上创建一个repo 起名必须规范 不用使用大写字母 像这样：[iostang.github.io](https://iostang.github.io)\n2. 创建两个分支 master · hexo\n3. 设置hexo为默认分支\n4. 使用git clone git@github.com:iostang/iostang.github.io.git 存放在自己想要管理博客的文件夹\n5. 在该目录下 依次使用\n\n\t\tsudo npm install -g hexo\n\t\thexo init\n\t\tnpm install \n\t\tnpm install hexo-deployer-git --save\n\t\t\n6. 修改_config.yml中的deploy参数\n\n\t\tdeploy:\n\t\ttype: git\n\t\trepo: git@github.com:iostang/iostang.github.io.git\n\t\tbranch: master\n\n7. hexo g 生成网站文件\n8. hexo s 这个时候就可以在本地查看博客了[http://localhost:4000](http://localhost:4000/)\n\n\t这个时候再点击http://localhost:4000，正常情况下应该是最原始的画面，但是我看到的是：\n\t白板和Cannot GET / 几个字\n\t\n\t原因：由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：\n\n\t\tnpm install hexo-renderer-ejs --save\n\t\tnpm install hexo-renderer-stylus --save\n\t\tnpm install hexo-renderer-marked --save\n\t\t\n\t**再次执行hexo g · hexo s**\n\n9. 依次执行 git add . git commit -m \"balabala\" git push origin hexo 提交相关文件到hexo分支\n10. 使用hexo g -d 生成网站并部署到github 注意提交到master分支上\n\n\n\n\n\t\t\n### 2 日常维护\n\n如果想写新的博客或者修改博客 你可以按照这个流程\n\n\t1. hexo n \"这是新博客的标题\"\n\t2. hexo g\n\t3. hexo s\n\t4. git add .\n\t5. git commit -m \"balabala\"\n\t6. git pull origin hexo \n\t7. git push origin hexo\n\t8. hexo d\n\n**ok 这个时候新博客已经部署到Github仓库了**\n\n\n### 3 如何管理 \n\n那如果我有多台电脑 该如何管理你的博客呢？\n\n\t1. git clone git@github.com:iostang/iostang.github.io.git\n\t2. sudo npm install -g hexo\n\t3. npm install hexo-renderer-ejs --save\n\t4. npm install hexo-renderer-stylus --save\n\t5. npm install hexo-renderer-marked --save\n\t6. npm install hexo-deployer-git --save\n\n千万不要执行**hexo init**这条指令 否则会覆盖_config.yml\n\n### 4 博客主题\n* 有了博客 当然想要一个风格好看你的主题 你可以去[这里](https://hexo.io/themes/)下载你喜欢的主题\n* 也可以使用[这个](https://github.com/pinggod/hexo-theme-apollo) 个人还蛮喜欢这种风格\n\t\n\t\tnpm install\n\t\tnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n\t\tgit clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo\n\t\t\n* 修改 _config.yml 的 theme 配置项为 apollo:\n\n\t\ttheme: apollo\n\n主题里面的内容就需要自己去配置了 比如微博账号\n    \n* 安装主题有一个小问题就是 在你提交到Github的时候 你需要先把该主题目录下的.git文件删掉 不然提交不上去\n\n","source":"_posts/Hexo-利用Github管理你的博客.md","raw":"\n---\ntitle: Hexo 利用Github管理博客\ndate: 2016-08-26 18:49:55\ntags: Hexo\n---\n\n# Hexo 利用Github管理博客\n\n\n### 1 搭建流程\n\n>配置环境\n安装homebrew node.js git \n申请Github\n算了这些就不写了。。。\n\n\n1. 在github上创建一个repo 起名必须规范 不用使用大写字母 像这样：[iostang.github.io](https://iostang.github.io)\n2. 创建两个分支 master · hexo\n3. 设置hexo为默认分支\n4. 使用git clone git@github.com:iostang/iostang.github.io.git 存放在自己想要管理博客的文件夹\n5. 在该目录下 依次使用\n\n\t\tsudo npm install -g hexo\n\t\thexo init\n\t\tnpm install \n\t\tnpm install hexo-deployer-git --save\n\t\t\n6. 修改_config.yml中的deploy参数\n\n\t\tdeploy:\n\t\ttype: git\n\t\trepo: git@github.com:iostang/iostang.github.io.git\n\t\tbranch: master\n\n7. hexo g 生成网站文件\n8. hexo s 这个时候就可以在本地查看博客了[http://localhost:4000](http://localhost:4000/)\n\n\t这个时候再点击http://localhost:4000，正常情况下应该是最原始的画面，但是我看到的是：\n\t白板和Cannot GET / 几个字\n\t\n\t原因：由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：\n\n\t\tnpm install hexo-renderer-ejs --save\n\t\tnpm install hexo-renderer-stylus --save\n\t\tnpm install hexo-renderer-marked --save\n\t\t\n\t**再次执行hexo g · hexo s**\n\n9. 依次执行 git add . git commit -m \"balabala\" git push origin hexo 提交相关文件到hexo分支\n10. 使用hexo g -d 生成网站并部署到github 注意提交到master分支上\n\n\n\n\n\t\t\n### 2 日常维护\n\n如果想写新的博客或者修改博客 你可以按照这个流程\n\n\t1. hexo n \"这是新博客的标题\"\n\t2. hexo g\n\t3. hexo s\n\t4. git add .\n\t5. git commit -m \"balabala\"\n\t6. git pull origin hexo \n\t7. git push origin hexo\n\t8. hexo d\n\n**ok 这个时候新博客已经部署到Github仓库了**\n\n\n### 3 如何管理 \n\n那如果我有多台电脑 该如何管理你的博客呢？\n\n\t1. git clone git@github.com:iostang/iostang.github.io.git\n\t2. sudo npm install -g hexo\n\t3. npm install hexo-renderer-ejs --save\n\t4. npm install hexo-renderer-stylus --save\n\t5. npm install hexo-renderer-marked --save\n\t6. npm install hexo-deployer-git --save\n\n千万不要执行**hexo init**这条指令 否则会覆盖_config.yml\n\n### 4 博客主题\n* 有了博客 当然想要一个风格好看你的主题 你可以去[这里](https://hexo.io/themes/)下载你喜欢的主题\n* 也可以使用[这个](https://github.com/pinggod/hexo-theme-apollo) 个人还蛮喜欢这种风格\n\t\n\t\tnpm install\n\t\tnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n\t\tgit clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo\n\t\t\n* 修改 _config.yml 的 theme 配置项为 apollo:\n\n\t\ttheme: apollo\n\n主题里面的内容就需要自己去配置了 比如微博账号\n    \n* 安装主题有一个小问题就是 在你提交到Github的时候 你需要先把该主题目录下的.git文件删掉 不然提交不上去\n\n","slug":"Hexo-利用Github管理你的博客","published":1,"updated":"2019-08-14T13:31:03.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzbbi8hz0000aq1kqlaj395s","content":"<h1 id=\"Hexo-利用Github管理博客\"><a href=\"#Hexo-利用Github管理博客\" class=\"headerlink\" title=\"Hexo 利用Github管理博客\"></a>Hexo 利用Github管理博客</h1><h3 id=\"1-搭建流程\"><a href=\"#1-搭建流程\" class=\"headerlink\" title=\"1 搭建流程\"></a>1 搭建流程</h3><blockquote>\n<p>配置环境<br>安装homebrew node.js git<br>申请Github<br>算了这些就不写了。。。</p>\n</blockquote>\n<ol>\n<li>在github上创建一个repo 起名必须规范 不用使用大写字母 像这样：<a href=\"https://iostang.github.io\" target=\"_blank\" rel=\"external\">iostang.github.io</a></li>\n<li>创建两个分支 master · hexo</li>\n<li>设置hexo为默认分支</li>\n<li>使用git clone git@github.com:iostang/iostang.github.io.git 存放在自己想要管理博客的文件夹</li>\n<li><p>在该目录下 依次使用</p>\n<pre><code>sudo npm install -g hexo\nhexo init\nnpm install \nnpm install hexo-deployer-git --save\n</code></pre></li>\n<li><p>修改_config.yml中的deploy参数</p>\n<pre><code>deploy:\ntype: git\nrepo: git@github.com:iostang/iostang.github.io.git\nbranch: master\n</code></pre></li>\n<li><p>hexo g 生成网站文件</p>\n</li>\n<li><p>hexo s 这个时候就可以在本地查看博客了<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></p>\n<p> 这个时候再点击<a href=\"http://localhost:4000，正常情况下应该是最原始的画面，但是我看到的是：\" target=\"_blank\" rel=\"external\">http://localhost:4000，正常情况下应该是最原始的画面，但是我看到的是：</a><br> 白板和Cannot GET / 几个字</p>\n<p> 原因：由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p>\n<pre><code>npm install hexo-renderer-ejs --save\nnpm install hexo-renderer-stylus --save\nnpm install hexo-renderer-marked --save\n</code></pre><p> <strong>再次执行hexo g · hexo s</strong></p>\n</li>\n<li><p>依次执行 git add . git commit -m “balabala” git push origin hexo 提交相关文件到hexo分支</p>\n</li>\n<li>使用hexo g -d 生成网站并部署到github 注意提交到master分支上</li>\n</ol>\n<h3 id=\"2-日常维护\"><a href=\"#2-日常维护\" class=\"headerlink\" title=\"2 日常维护\"></a>2 日常维护</h3><p>如果想写新的博客或者修改博客 你可以按照这个流程</p>\n<pre><code>1. hexo n &quot;这是新博客的标题&quot;\n2. hexo g\n3. hexo s\n4. git add .\n5. git commit -m &quot;balabala&quot;\n6. git pull origin hexo \n7. git push origin hexo\n8. hexo d\n</code></pre><p><strong>ok 这个时候新博客已经部署到Github仓库了</strong></p>\n<h3 id=\"3-如何管理\"><a href=\"#3-如何管理\" class=\"headerlink\" title=\"3 如何管理\"></a>3 如何管理</h3><p>那如果我有多台电脑 该如何管理你的博客呢？</p>\n<pre><code>1. git clone git@github.com:iostang/iostang.github.io.git\n2. sudo npm install -g hexo\n3. npm install hexo-renderer-ejs --save\n4. npm install hexo-renderer-stylus --save\n5. npm install hexo-renderer-marked --save\n6. npm install hexo-deployer-git --save\n</code></pre><p>千万不要执行<strong>hexo init</strong>这条指令 否则会覆盖_config.yml</p>\n<h3 id=\"4-博客主题\"><a href=\"#4-博客主题\" class=\"headerlink\" title=\"4 博客主题\"></a>4 博客主题</h3><ul>\n<li>有了博客 当然想要一个风格好看你的主题 你可以去<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">这里</a>下载你喜欢的主题</li>\n<li><p>也可以使用<a href=\"https://github.com/pinggod/hexo-theme-apollo\" target=\"_blank\" rel=\"external\">这个</a> 个人还蛮喜欢这种风格</p>\n<pre><code>npm install\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\ngit clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo\n</code></pre></li>\n<li><p>修改 _config.yml 的 theme 配置项为 apollo:</p>\n<pre><code>theme: apollo\n</code></pre></li>\n</ul>\n<p>主题里面的内容就需要自己去配置了 比如微博账号</p>\n<ul>\n<li>安装主题有一个小问题就是 在你提交到Github的时候 你需要先把该主题目录下的.git文件删掉 不然提交不上去</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Hexo-利用Github管理博客\"><a href=\"#Hexo-利用Github管理博客\" class=\"headerlink\" title=\"Hexo 利用Github管理博客\"></a>Hexo 利用Github管理博客</h1><h3 id=\"1-搭建流程\"><a href=\"#1-搭建流程\" class=\"headerlink\" title=\"1 搭建流程\"></a>1 搭建流程</h3><blockquote>\n<p>配置环境<br>安装homebrew node.js git<br>申请Github<br>算了这些就不写了。。。</p>\n</blockquote>\n<ol>\n<li>在github上创建一个repo 起名必须规范 不用使用大写字母 像这样：<a href=\"https://iostang.github.io\">iostang.github.io</a></li>\n<li>创建两个分支 master · hexo</li>\n<li>设置hexo为默认分支</li>\n<li>使用git clone git@github.com:iostang/iostang.github.io.git 存放在自己想要管理博客的文件夹</li>\n<li><p>在该目录下 依次使用</p>\n<pre><code>sudo npm install -g hexo\nhexo init\nnpm install \nnpm install hexo-deployer-git --save\n</code></pre></li>\n<li><p>修改_config.yml中的deploy参数</p>\n<pre><code>deploy:\ntype: git\nrepo: git@github.com:iostang/iostang.github.io.git\nbranch: master\n</code></pre></li>\n<li><p>hexo g 生成网站文件</p>\n</li>\n<li><p>hexo s 这个时候就可以在本地查看博客了<a href=\"http://localhost:4000/\">http://localhost:4000</a></p>\n<p> 这个时候再点击<a href=\"http://localhost:4000，正常情况下应该是最原始的画面，但是我看到的是：\">http://localhost:4000，正常情况下应该是最原始的画面，但是我看到的是：</a><br> 白板和Cannot GET / 几个字</p>\n<p> 原因：由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：</p>\n<pre><code>npm install hexo-renderer-ejs --save\nnpm install hexo-renderer-stylus --save\nnpm install hexo-renderer-marked --save\n</code></pre><p> <strong>再次执行hexo g · hexo s</strong></p>\n</li>\n<li><p>依次执行 git add . git commit -m “balabala” git push origin hexo 提交相关文件到hexo分支</p>\n</li>\n<li>使用hexo g -d 生成网站并部署到github 注意提交到master分支上</li>\n</ol>\n<h3 id=\"2-日常维护\"><a href=\"#2-日常维护\" class=\"headerlink\" title=\"2 日常维护\"></a>2 日常维护</h3><p>如果想写新的博客或者修改博客 你可以按照这个流程</p>\n<pre><code>1. hexo n &quot;这是新博客的标题&quot;\n2. hexo g\n3. hexo s\n4. git add .\n5. git commit -m &quot;balabala&quot;\n6. git pull origin hexo \n7. git push origin hexo\n8. hexo d\n</code></pre><p><strong>ok 这个时候新博客已经部署到Github仓库了</strong></p>\n<h3 id=\"3-如何管理\"><a href=\"#3-如何管理\" class=\"headerlink\" title=\"3 如何管理\"></a>3 如何管理</h3><p>那如果我有多台电脑 该如何管理你的博客呢？</p>\n<pre><code>1. git clone git@github.com:iostang/iostang.github.io.git\n2. sudo npm install -g hexo\n3. npm install hexo-renderer-ejs --save\n4. npm install hexo-renderer-stylus --save\n5. npm install hexo-renderer-marked --save\n6. npm install hexo-deployer-git --save\n</code></pre><p>千万不要执行<strong>hexo init</strong>这条指令 否则会覆盖_config.yml</p>\n<h3 id=\"4-博客主题\"><a href=\"#4-博客主题\" class=\"headerlink\" title=\"4 博客主题\"></a>4 博客主题</h3><ul>\n<li>有了博客 当然想要一个风格好看你的主题 你可以去<a href=\"https://hexo.io/themes/\">这里</a>下载你喜欢的主题</li>\n<li><p>也可以使用<a href=\"https://github.com/pinggod/hexo-theme-apollo\">这个</a> 个人还蛮喜欢这种风格</p>\n<pre><code>npm install\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\ngit clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo\n</code></pre></li>\n<li><p>修改 _config.yml 的 theme 配置项为 apollo:</p>\n<pre><code>theme: apollo\n</code></pre></li>\n</ul>\n<p>主题里面的内容就需要自己去配置了 比如微博账号</p>\n<ul>\n<li>安装主题有一个小问题就是 在你提交到Github的时候 你需要先把该主题目录下的.git文件删掉 不然提交不上去</li>\n</ul>\n"},{"title":"LKImageKit 简述","date":"2019-08-14T13:31:17.000Z","_content":"\n\n \n# 简介   \n\nLKImageKit是一个高性能的图片框架，包括了图片控件，图片下载、内存缓存、磁盘缓存、图片解码、图片处理等一系列能力。合理的架构和线程模型，并特别针对不同场景进行优化，能充分发挥硬件的性能。\n   \n同时，该框架具有高度的扩展性。在此框架下，开发者可以自定义图片框架中的任何一个部分，比如：自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法等等。\n\n# 结构\n\n### 架构图\n\n![image](http://iostang.github.io/images/LKImageKit_architecture.png)\n\n## 目录结构\n   \n    Core\n        Class\n            LKImageView\n            LKImageRequest\n            LKImageError\n            LKImageConfiguration\n            LKImageInfo\n        Manager\n            LKImageDecoderManager\n            LKImageLoaderManager\n            LKImageManager\n            LKImageProcessorManager\n            LKImageCacheManager\n            LKImageLogManager\n        Utility\n            LKImageMonitor\n            LKImageUtil\n        Private\n            ...\n    Components\n        Cache\n            LKImageMemoryCache\n            LKImageSmartCache\n        Loader\n            LKImageBundleLoader\n            LKImageLocalFileLoader  \n            LKImageMemoryImageLoader\n            LKImageNetworkFileLoader\n            LKImagePhotoKitLoader\n        Decoder\n            LKImageSystemDecoder\n        Processor\n            LKImageBlurProcessor\n            LKImageGrayProcessor\n            LKImagePredrawProcessor\n            LKImageSpritesToMutipleImagesProcessor\n### 流程图\n\n![image](http://iostang.github.io/images/LKImageKit_flow.png)\n       \n\n# 实现细节\n\n### 1 缓存\n\n*内存缓存*\n   \n    第一：使用LRU+FIFO双队列的改进算法，提高缓存的命中率，解决进入新页面的突发大量图片的缓存污染问题。\n    第二：使用缓存模糊匹配算法。对于图片请求，如果发现缓存中有比请求大小更大的图片，则也视为命中缓存。\n    第三：使用C++编写缓存，组合链表和哈希表的存储结构，可以把LRU队列的增删查的时间复杂度将为O(1)\n\n*磁盘缓存*\n\n    只有网络图片用 相册图片、本地图片不需要磁盘缓存\n    //将url MD5后当中文件名 然后把data写入到 Library/Caches/images/\n    NSURL *fileURL = [NSURL fileURLWithPath:[LKImageNetworkFileLoader cacheFilePathForURL:request.keyForLoader]];\n    [data writeToURL:fileURL atomically:YES];\n      \n### 2 图片请求\n\n磁盘缓存IO速度，和图片的下载速度是比较慢的，如果我们在一个图片加载完成之前再发出同样的请求，不可避免的会导致重复的磁盘读取和图片下载。\n\n因此，在此基础上，我们还可以添加一个请求队列，实现对图片请求的去重。对于相同的请求，我们进行合并，在请求完成之后，批量进行回调。这样就可以防止同一个url重复请求导致的多次缓存查询和重复下载问题。\n\n[LKImageLoaderManager imageWithRequest function]\n\n\n### 3 图片处理\n\n有的图片并不是直接展示，而是需要进行处理，比如套用一个滤镜\n\n因此，我们在原有的架构上再添加一个模块，图像处理模块，一方面解决上述的图片处理的问题。另一方面，在这个模块，对加载的图片进行一次绘制。这是由于iOS的特性，UIImage加载之后并没有立即解码，而是在显示或其他需要的时候解码，我们需要进行一次绘制，强制系统进行解码。\n\n### 4 自定义\n\n自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法\n\n详情可看:\n    \n    ExampleFastFileCache.m\n    ExampleNetworkFileLoader.m\n    ExampleImageURLRequest.m\n    LKImageWebPDecoder.m\n    \n\n### 多线程 高性能 内存占用优化\n\n\n\n## 用法\n\n    //使用LKImageView\n    网络图片：imageView.URL = \"http://dsadsada.jpg\"\n    相册图片：imageView.URL = \"phasset://\" + \"图片identifier\"\n    本地图片：imageView.URL = \"file://\" + \"图片路径\"\n    沙盒图片：imageView.URL = \"图片沙盒地址\"\n    还可以设置 loadingURL failureURL  用法同上\n        \n    //或者这样：\n    imageView.loadingImage = UIImage(named: \"loading\")\n    imageView.failureImage = UIImage(named: \"failure\")\n    imageView.defaultImage = UIImage(named: \"default\")\n        \n    //其他设置\n    imageView.effect.blurEnabled = true\n    imageView.effect.grayEnabled = false\n    imageView.scaleMode = LKImageScaleMode(rawValue: 3)\n    imageView.predrawEnabled = true\n    imageView.anchorPoint = CGPointMake(100, 5)\n    imageView.fadeMode = LKImageViewFadeMode(rawValue: 2)\n    \n    //渐进式加载\n    LKImageURLRequest *request = [LKImageURLRequest requestWithURL: @\"http://dsadsadsa.jpg\"];\n    //开启这个属性即可\n    request.supportProgressive = true;\n    imageView.request = request;\n\n\n# 知识点\n\n    1 多线程（gcd信号量 线程锁 独立线程 并发控制 优先级）\n    2 图片处理（模糊 灰度 预加载 解码 渐进式加载）\n    3 链表 LRU MapTable\n    \n    \n    \n# 资料\n    \n[LRU、LFU、FIFO算法](https://www.jianshu.com/p/2bed0e361b86)\n[@Swift开发者大会——如何打造易扩展的高性能图片组件](https://zhuanlan.zhihu.com/p/26955368)\n[iOS中的NSHashTable和NSMapTable](https://www.jianshu.com/p/dcd222900fa9)\n[关于dispatch_semaphore的使用](http://www.cnblogs.com/snailHL/p/3906112.html)\n[NSOperation和NSOperationQueue的一些事儿](https://www.jianshu.com/p/f5eddfe074fe)\n[相对于SDWebImage的优势在哪里](https://github.com/Tencent/LKImageKit/issues/5)\n\n\n","source":"_posts/LKImageKit-简述.md","raw":"---\ntitle: LKImageKit 简述\ndate: 2019-08-14 21:31:17\ntags:\n---\n\n\n \n# 简介   \n\nLKImageKit是一个高性能的图片框架，包括了图片控件，图片下载、内存缓存、磁盘缓存、图片解码、图片处理等一系列能力。合理的架构和线程模型，并特别针对不同场景进行优化，能充分发挥硬件的性能。\n   \n同时，该框架具有高度的扩展性。在此框架下，开发者可以自定义图片框架中的任何一个部分，比如：自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法等等。\n\n# 结构\n\n### 架构图\n\n![image](http://iostang.github.io/images/LKImageKit_architecture.png)\n\n## 目录结构\n   \n    Core\n        Class\n            LKImageView\n            LKImageRequest\n            LKImageError\n            LKImageConfiguration\n            LKImageInfo\n        Manager\n            LKImageDecoderManager\n            LKImageLoaderManager\n            LKImageManager\n            LKImageProcessorManager\n            LKImageCacheManager\n            LKImageLogManager\n        Utility\n            LKImageMonitor\n            LKImageUtil\n        Private\n            ...\n    Components\n        Cache\n            LKImageMemoryCache\n            LKImageSmartCache\n        Loader\n            LKImageBundleLoader\n            LKImageLocalFileLoader  \n            LKImageMemoryImageLoader\n            LKImageNetworkFileLoader\n            LKImagePhotoKitLoader\n        Decoder\n            LKImageSystemDecoder\n        Processor\n            LKImageBlurProcessor\n            LKImageGrayProcessor\n            LKImagePredrawProcessor\n            LKImageSpritesToMutipleImagesProcessor\n### 流程图\n\n![image](http://iostang.github.io/images/LKImageKit_flow.png)\n       \n\n# 实现细节\n\n### 1 缓存\n\n*内存缓存*\n   \n    第一：使用LRU+FIFO双队列的改进算法，提高缓存的命中率，解决进入新页面的突发大量图片的缓存污染问题。\n    第二：使用缓存模糊匹配算法。对于图片请求，如果发现缓存中有比请求大小更大的图片，则也视为命中缓存。\n    第三：使用C++编写缓存，组合链表和哈希表的存储结构，可以把LRU队列的增删查的时间复杂度将为O(1)\n\n*磁盘缓存*\n\n    只有网络图片用 相册图片、本地图片不需要磁盘缓存\n    //将url MD5后当中文件名 然后把data写入到 Library/Caches/images/\n    NSURL *fileURL = [NSURL fileURLWithPath:[LKImageNetworkFileLoader cacheFilePathForURL:request.keyForLoader]];\n    [data writeToURL:fileURL atomically:YES];\n      \n### 2 图片请求\n\n磁盘缓存IO速度，和图片的下载速度是比较慢的，如果我们在一个图片加载完成之前再发出同样的请求，不可避免的会导致重复的磁盘读取和图片下载。\n\n因此，在此基础上，我们还可以添加一个请求队列，实现对图片请求的去重。对于相同的请求，我们进行合并，在请求完成之后，批量进行回调。这样就可以防止同一个url重复请求导致的多次缓存查询和重复下载问题。\n\n[LKImageLoaderManager imageWithRequest function]\n\n\n### 3 图片处理\n\n有的图片并不是直接展示，而是需要进行处理，比如套用一个滤镜\n\n因此，我们在原有的架构上再添加一个模块，图像处理模块，一方面解决上述的图片处理的问题。另一方面，在这个模块，对加载的图片进行一次绘制。这是由于iOS的特性，UIImage加载之后并没有立即解码，而是在显示或其他需要的时候解码，我们需要进行一次绘制，强制系统进行解码。\n\n### 4 自定义\n\n自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法\n\n详情可看:\n    \n    ExampleFastFileCache.m\n    ExampleNetworkFileLoader.m\n    ExampleImageURLRequest.m\n    LKImageWebPDecoder.m\n    \n\n### 多线程 高性能 内存占用优化\n\n\n\n## 用法\n\n    //使用LKImageView\n    网络图片：imageView.URL = \"http://dsadsada.jpg\"\n    相册图片：imageView.URL = \"phasset://\" + \"图片identifier\"\n    本地图片：imageView.URL = \"file://\" + \"图片路径\"\n    沙盒图片：imageView.URL = \"图片沙盒地址\"\n    还可以设置 loadingURL failureURL  用法同上\n        \n    //或者这样：\n    imageView.loadingImage = UIImage(named: \"loading\")\n    imageView.failureImage = UIImage(named: \"failure\")\n    imageView.defaultImage = UIImage(named: \"default\")\n        \n    //其他设置\n    imageView.effect.blurEnabled = true\n    imageView.effect.grayEnabled = false\n    imageView.scaleMode = LKImageScaleMode(rawValue: 3)\n    imageView.predrawEnabled = true\n    imageView.anchorPoint = CGPointMake(100, 5)\n    imageView.fadeMode = LKImageViewFadeMode(rawValue: 2)\n    \n    //渐进式加载\n    LKImageURLRequest *request = [LKImageURLRequest requestWithURL: @\"http://dsadsadsa.jpg\"];\n    //开启这个属性即可\n    request.supportProgressive = true;\n    imageView.request = request;\n\n\n# 知识点\n\n    1 多线程（gcd信号量 线程锁 独立线程 并发控制 优先级）\n    2 图片处理（模糊 灰度 预加载 解码 渐进式加载）\n    3 链表 LRU MapTable\n    \n    \n    \n# 资料\n    \n[LRU、LFU、FIFO算法](https://www.jianshu.com/p/2bed0e361b86)\n[@Swift开发者大会——如何打造易扩展的高性能图片组件](https://zhuanlan.zhihu.com/p/26955368)\n[iOS中的NSHashTable和NSMapTable](https://www.jianshu.com/p/dcd222900fa9)\n[关于dispatch_semaphore的使用](http://www.cnblogs.com/snailHL/p/3906112.html)\n[NSOperation和NSOperationQueue的一些事儿](https://www.jianshu.com/p/f5eddfe074fe)\n[相对于SDWebImage的优势在哪里](https://github.com/Tencent/LKImageKit/issues/5)\n\n\n","slug":"LKImageKit-简述","published":1,"updated":"2019-08-14T13:55:17.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzbbi8i30001aq1kckoby615","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>LKImageKit是一个高性能的图片框架，包括了图片控件，图片下载、内存缓存、磁盘缓存、图片解码、图片处理等一系列能力。合理的架构和线程模型，并特别针对不同场景进行优化，能充分发挥硬件的性能。</p>\n<p>同时，该框架具有高度的扩展性。在此框架下，开发者可以自定义图片框架中的任何一个部分，比如：自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法等等。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h3 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h3><p><img src=\"http://iostang.github.io/images/LKImageKit_architecture.png\" alt=\"image\"></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><pre><code>Core\n    Class\n        LKImageView\n        LKImageRequest\n        LKImageError\n        LKImageConfiguration\n        LKImageInfo\n    Manager\n        LKImageDecoderManager\n        LKImageLoaderManager\n        LKImageManager\n        LKImageProcessorManager\n        LKImageCacheManager\n        LKImageLogManager\n    Utility\n        LKImageMonitor\n        LKImageUtil\n    Private\n        ...\nComponents\n    Cache\n        LKImageMemoryCache\n        LKImageSmartCache\n    Loader\n        LKImageBundleLoader\n        LKImageLocalFileLoader  \n        LKImageMemoryImageLoader\n        LKImageNetworkFileLoader\n        LKImagePhotoKitLoader\n    Decoder\n        LKImageSystemDecoder\n    Processor\n        LKImageBlurProcessor\n        LKImageGrayProcessor\n        LKImagePredrawProcessor\n        LKImageSpritesToMutipleImagesProcessor\n</code></pre><h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h3><p><img src=\"http://iostang.github.io/images/LKImageKit_flow.png\" alt=\"image\"></p>\n<h1 id=\"实现细节\"><a href=\"#实现细节\" class=\"headerlink\" title=\"实现细节\"></a>实现细节</h1><h3 id=\"1-缓存\"><a href=\"#1-缓存\" class=\"headerlink\" title=\"1 缓存\"></a>1 缓存</h3><p><em>内存缓存</em></p>\n<pre><code>第一：使用LRU+FIFO双队列的改进算法，提高缓存的命中率，解决进入新页面的突发大量图片的缓存污染问题。\n第二：使用缓存模糊匹配算法。对于图片请求，如果发现缓存中有比请求大小更大的图片，则也视为命中缓存。\n第三：使用C++编写缓存，组合链表和哈希表的存储结构，可以把LRU队列的增删查的时间复杂度将为O(1)\n</code></pre><p><em>磁盘缓存</em></p>\n<pre><code>只有网络图片用 相册图片、本地图片不需要磁盘缓存\n//将url MD5后当中文件名 然后把data写入到 Library/Caches/images/\nNSURL *fileURL = [NSURL fileURLWithPath:[LKImageNetworkFileLoader cacheFilePathForURL:request.keyForLoader]];\n[data writeToURL:fileURL atomically:YES];\n</code></pre><h3 id=\"2-图片请求\"><a href=\"#2-图片请求\" class=\"headerlink\" title=\"2 图片请求\"></a>2 图片请求</h3><p>磁盘缓存IO速度，和图片的下载速度是比较慢的，如果我们在一个图片加载完成之前再发出同样的请求，不可避免的会导致重复的磁盘读取和图片下载。</p>\n<p>因此，在此基础上，我们还可以添加一个请求队列，实现对图片请求的去重。对于相同的请求，我们进行合并，在请求完成之后，批量进行回调。这样就可以防止同一个url重复请求导致的多次缓存查询和重复下载问题。</p>\n<p>[LKImageLoaderManager imageWithRequest function]</p>\n<h3 id=\"3-图片处理\"><a href=\"#3-图片处理\" class=\"headerlink\" title=\"3 图片处理\"></a>3 图片处理</h3><p>有的图片并不是直接展示，而是需要进行处理，比如套用一个滤镜</p>\n<p>因此，我们在原有的架构上再添加一个模块，图像处理模块，一方面解决上述的图片处理的问题。另一方面，在这个模块，对加载的图片进行一次绘制。这是由于iOS的特性，UIImage加载之后并没有立即解码，而是在显示或其他需要的时候解码，我们需要进行一次绘制，强制系统进行解码。</p>\n<h3 id=\"4-自定义\"><a href=\"#4-自定义\" class=\"headerlink\" title=\"4 自定义\"></a>4 自定义</h3><p>自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法</p>\n<p>详情可看:</p>\n<pre><code>ExampleFastFileCache.m\nExampleNetworkFileLoader.m\nExampleImageURLRequest.m\nLKImageWebPDecoder.m\n</code></pre><h3 id=\"多线程-高性能-内存占用优化\"><a href=\"#多线程-高性能-内存占用优化\" class=\"headerlink\" title=\"多线程 高性能 内存占用优化\"></a>多线程 高性能 内存占用优化</h3><h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre><code>//使用LKImageView\n网络图片：imageView.URL = &quot;http://dsadsada.jpg&quot;\n相册图片：imageView.URL = &quot;phasset://&quot; + &quot;图片identifier&quot;\n本地图片：imageView.URL = &quot;file://&quot; + &quot;图片路径&quot;\n沙盒图片：imageView.URL = &quot;图片沙盒地址&quot;\n还可以设置 loadingURL failureURL  用法同上\n\n//或者这样：\nimageView.loadingImage = UIImage(named: &quot;loading&quot;)\nimageView.failureImage = UIImage(named: &quot;failure&quot;)\nimageView.defaultImage = UIImage(named: &quot;default&quot;)\n\n//其他设置\nimageView.effect.blurEnabled = true\nimageView.effect.grayEnabled = false\nimageView.scaleMode = LKImageScaleMode(rawValue: 3)\nimageView.predrawEnabled = true\nimageView.anchorPoint = CGPointMake(100, 5)\nimageView.fadeMode = LKImageViewFadeMode(rawValue: 2)\n\n//渐进式加载\nLKImageURLRequest *request = [LKImageURLRequest requestWithURL: @&quot;http://dsadsadsa.jpg&quot;];\n//开启这个属性即可\nrequest.supportProgressive = true;\nimageView.request = request;\n</code></pre><h1 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h1><pre><code>1 多线程（gcd信号量 线程锁 独立线程 并发控制 优先级）\n2 图片处理（模糊 灰度 预加载 解码 渐进式加载）\n3 链表 LRU MapTable\n</code></pre><h1 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h1><p><a href=\"https://www.jianshu.com/p/2bed0e361b86\" target=\"_blank\" rel=\"external\">LRU、LFU、FIFO算法</a><br><a href=\"https://zhuanlan.zhihu.com/p/26955368\" target=\"_blank\" rel=\"external\">@Swift开发者大会——如何打造易扩展的高性能图片组件</a><br><a href=\"https://www.jianshu.com/p/dcd222900fa9\" target=\"_blank\" rel=\"external\">iOS中的NSHashTable和NSMapTable</a><br><a href=\"http://www.cnblogs.com/snailHL/p/3906112.html\" target=\"_blank\" rel=\"external\">关于dispatch_semaphore的使用</a><br><a href=\"https://www.jianshu.com/p/f5eddfe074fe\" target=\"_blank\" rel=\"external\">NSOperation和NSOperationQueue的一些事儿</a><br><a href=\"https://github.com/Tencent/LKImageKit/issues/5\" target=\"_blank\" rel=\"external\">相对于SDWebImage的优势在哪里</a></p>\n","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>LKImageKit是一个高性能的图片框架，包括了图片控件，图片下载、内存缓存、磁盘缓存、图片解码、图片处理等一系列能力。合理的架构和线程模型，并特别针对不同场景进行优化，能充分发挥硬件的性能。</p>\n<p>同时，该框架具有高度的扩展性。在此框架下，开发者可以自定义图片框架中的任何一个部分，比如：自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法等等。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h3 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h3><p><img src=\"http://iostang.github.io/images/LKImageKit_architecture.png\" alt=\"image\"></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><pre><code>Core\n    Class\n        LKImageView\n        LKImageRequest\n        LKImageError\n        LKImageConfiguration\n        LKImageInfo\n    Manager\n        LKImageDecoderManager\n        LKImageLoaderManager\n        LKImageManager\n        LKImageProcessorManager\n        LKImageCacheManager\n        LKImageLogManager\n    Utility\n        LKImageMonitor\n        LKImageUtil\n    Private\n        ...\nComponents\n    Cache\n        LKImageMemoryCache\n        LKImageSmartCache\n    Loader\n        LKImageBundleLoader\n        LKImageLocalFileLoader  \n        LKImageMemoryImageLoader\n        LKImageNetworkFileLoader\n        LKImagePhotoKitLoader\n    Decoder\n        LKImageSystemDecoder\n    Processor\n        LKImageBlurProcessor\n        LKImageGrayProcessor\n        LKImagePredrawProcessor\n        LKImageSpritesToMutipleImagesProcessor\n</code></pre><h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h3><p><img src=\"http://iostang.github.io/images/LKImageKit_flow.png\" alt=\"image\"></p>\n<h1 id=\"实现细节\"><a href=\"#实现细节\" class=\"headerlink\" title=\"实现细节\"></a>实现细节</h1><h3 id=\"1-缓存\"><a href=\"#1-缓存\" class=\"headerlink\" title=\"1 缓存\"></a>1 缓存</h3><p><em>内存缓存</em></p>\n<pre><code>第一：使用LRU+FIFO双队列的改进算法，提高缓存的命中率，解决进入新页面的突发大量图片的缓存污染问题。\n第二：使用缓存模糊匹配算法。对于图片请求，如果发现缓存中有比请求大小更大的图片，则也视为命中缓存。\n第三：使用C++编写缓存，组合链表和哈希表的存储结构，可以把LRU队列的增删查的时间复杂度将为O(1)\n</code></pre><p><em>磁盘缓存</em></p>\n<pre><code>只有网络图片用 相册图片、本地图片不需要磁盘缓存\n//将url MD5后当中文件名 然后把data写入到 Library/Caches/images/\nNSURL *fileURL = [NSURL fileURLWithPath:[LKImageNetworkFileLoader cacheFilePathForURL:request.keyForLoader]];\n[data writeToURL:fileURL atomically:YES];\n</code></pre><h3 id=\"2-图片请求\"><a href=\"#2-图片请求\" class=\"headerlink\" title=\"2 图片请求\"></a>2 图片请求</h3><p>磁盘缓存IO速度，和图片的下载速度是比较慢的，如果我们在一个图片加载完成之前再发出同样的请求，不可避免的会导致重复的磁盘读取和图片下载。</p>\n<p>因此，在此基础上，我们还可以添加一个请求队列，实现对图片请求的去重。对于相同的请求，我们进行合并，在请求完成之后，批量进行回调。这样就可以防止同一个url重复请求导致的多次缓存查询和重复下载问题。</p>\n<p>[LKImageLoaderManager imageWithRequest function]</p>\n<h3 id=\"3-图片处理\"><a href=\"#3-图片处理\" class=\"headerlink\" title=\"3 图片处理\"></a>3 图片处理</h3><p>有的图片并不是直接展示，而是需要进行处理，比如套用一个滤镜</p>\n<p>因此，我们在原有的架构上再添加一个模块，图像处理模块，一方面解决上述的图片处理的问题。另一方面，在这个模块，对加载的图片进行一次绘制。这是由于iOS的特性，UIImage加载之后并没有立即解码，而是在显示或其他需要的时候解码，我们需要进行一次绘制，强制系统进行解码。</p>\n<h3 id=\"4-自定义\"><a href=\"#4-自定义\" class=\"headerlink\" title=\"4 自定义\"></a>4 自定义</h3><p>自定义图片显示逻辑、自定义缓存、自定义下载组件、自定义解码器、自定义图片处理算法</p>\n<p>详情可看:</p>\n<pre><code>ExampleFastFileCache.m\nExampleNetworkFileLoader.m\nExampleImageURLRequest.m\nLKImageWebPDecoder.m\n</code></pre><h3 id=\"多线程-高性能-内存占用优化\"><a href=\"#多线程-高性能-内存占用优化\" class=\"headerlink\" title=\"多线程 高性能 内存占用优化\"></a>多线程 高性能 内存占用优化</h3><h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><pre><code>//使用LKImageView\n网络图片：imageView.URL = &quot;http://dsadsada.jpg&quot;\n相册图片：imageView.URL = &quot;phasset://&quot; + &quot;图片identifier&quot;\n本地图片：imageView.URL = &quot;file://&quot; + &quot;图片路径&quot;\n沙盒图片：imageView.URL = &quot;图片沙盒地址&quot;\n还可以设置 loadingURL failureURL  用法同上\n\n//或者这样：\nimageView.loadingImage = UIImage(named: &quot;loading&quot;)\nimageView.failureImage = UIImage(named: &quot;failure&quot;)\nimageView.defaultImage = UIImage(named: &quot;default&quot;)\n\n//其他设置\nimageView.effect.blurEnabled = true\nimageView.effect.grayEnabled = false\nimageView.scaleMode = LKImageScaleMode(rawValue: 3)\nimageView.predrawEnabled = true\nimageView.anchorPoint = CGPointMake(100, 5)\nimageView.fadeMode = LKImageViewFadeMode(rawValue: 2)\n\n//渐进式加载\nLKImageURLRequest *request = [LKImageURLRequest requestWithURL: @&quot;http://dsadsadsa.jpg&quot;];\n//开启这个属性即可\nrequest.supportProgressive = true;\nimageView.request = request;\n</code></pre><h1 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h1><pre><code>1 多线程（gcd信号量 线程锁 独立线程 并发控制 优先级）\n2 图片处理（模糊 灰度 预加载 解码 渐进式加载）\n3 链表 LRU MapTable\n</code></pre><h1 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h1><p><a href=\"https://www.jianshu.com/p/2bed0e361b86\">LRU、LFU、FIFO算法</a><br><a href=\"https://zhuanlan.zhihu.com/p/26955368\">@Swift开发者大会——如何打造易扩展的高性能图片组件</a><br><a href=\"https://www.jianshu.com/p/dcd222900fa9\">iOS中的NSHashTable和NSMapTable</a><br><a href=\"http://www.cnblogs.com/snailHL/p/3906112.html\">关于dispatch_semaphore的使用</a><br><a href=\"https://www.jianshu.com/p/f5eddfe074fe\">NSOperation和NSOperationQueue的一些事儿</a><br><a href=\"https://github.com/Tencent/LKImageKit/issues/5\">相对于SDWebImage的优势在哪里</a></p>\n"},{"title":"git-flow","date":"2018-05-25T07:01:12.000Z","_content":"\n\n#git-flow 使用\n\n\n##安装 git-flow\n    \n    brew install git-flow\n\n*要了解安装 git-flow 细节，请阅读下面这个文档 [official documentation](https://github.com/petervanderdoes/gitflow/wiki#installing-git-flow)。*\n\n##在项目中设置 git-flow\n    \n    ➜  GitFlow git:(master) git flow init\n\n    Which branch should be used for bringing forth production releases?\n       - master\n    Branch name for production releases: [master]\n    Branch name for \"next release\" development: [develop]\n    \n    How to name your supporting branch prefixes?\n    Feature branches? [feature/]\n    Bugfix branches? [bugfix/]\n    Release branches? [release/]\n    Hotfix branches? [hotfix/]\n    Support branches? [support/]\n    Version tag prefix? []\n    Hooks and filters directory? [/Users/tonytong/Desktop/GitFlow/.git/hooks\n\n\n##功能开发\n对于一个开发人员来说，最平常的工作可能就是功能的开发。这就是为什么 git-flow 定义了很多对于功能开发的工作流程，从而来帮助你有组织地完成它。\n\n**Feature 开始开发一个新功能**\n    \n\n    ➜  GitFlow git:(develop) git flow feature start test-gitflow\n    Switched to a new branch 'feature/test-gitflow'\n    \n    Summary of actions:\n    - A new branch 'feature/test-gitflow' was created, based on 'develop'\n    - You are now on branch 'feature/test-gitflow'\n    \n    Now, start committing on your feature. When done, use:\n    \n         git flow feature finish test-gitflow\n         \n    \n    上面的 git flow feature start test-gitflow 会基于develop创建一个新的分支test-gitflow 并自动切换到该分支\n\n\n**Feature 完成一个新功能**\n    \n    ➜  GitFlow git:(feature/test-gitflow) git flow feature finish test-gitflow\n    Switched to branch 'develop'\n    Updating 862396e..e367e7c\n    Fast-forward\n     GitFlow/ViewController.swift | 2 ++\n     1 file changed, 2 insertions(+)\n    Deleted branch feature/test-gitflow (was e367e7c).\n    \n    Summary of actions:\n    - The feature branch 'feature/test-gitflow' was merged into 'develop'\n    - Feature branch 'feature/test-gitflow' has been locally deleted\n    - You are now on branch 'develop'\n\n执行feature finish之后会把我们的工作整合到主 “develop” 分支中去 \n而且还会删除这个当下已经完成的功能分支 并且自动切换到 “develop” 分支 \n\n**创建Release**\n\n    ➜  GitFlow git:(develop) git flow release start 1.0.0\n    Switched to a new branch 'release/1.0.0'\n    \n    Summary of actions:\n    - A new branch 'release/1.0.0' was created, based on 'develop'\n    - You are now on branch 'release/1.0.0'\n    \n    Follow-up actions:\n    - Bump the version number now!\n    - Start committing last-minute fixes in preparing your release\n    - When done, run:\n    \n         git flow release finish '1.0.0'\n         \n    \n请注意，release 分支是使用版本号命名的。这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地_自动_去标记那些 release 提交。\n\n有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。\n\n\n         \n**完成Release**\n\n    ➜  GitFlow git:(release/1.0.0) git flow release finish -m \"*release) finish\"\n    Switched to branch 'master'\n    Merge made by the 'recursive' strategy.\n     GitFlow/ViewController.swift | 1 +\n     1 file changed, 1 insertion(+)\n    Already on 'master'\n    Switched to branch 'develop'\n    Already up to date!\n    Merge made by the 'recursive' strategy.\n    Deleted branch release/1.0.0 (was 93ae994).\n    \n    Summary of actions:\n    - Release branch 'release/1.0.0' has been merged into 'master'\n    - The release was tagged '1.0.0'\n    - Release tag '1.0.0' has been back-merged into 'develop'\n    - Release branch 'release/1.0.0' has been locally deleted\n    - You are now on branch 'develop'\n\n\n    这个命令会完成如下一系列的操作：\n\n    1 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。\n    2 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。\n    3 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.0.0”）。\n    4 清理操作，版本分支会被删除，并且回到 “develop”。\n    \n    从 Git 的角度来看，release 版本现在已经完成。依据你的设置，\n    对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，\n    来让你的软件产品进入你的用户手中。\n\n\n**创建Hotfix**\n\n    ➜  GitFlow git:(develop) git flow hotfix start crash-login\n    Switched to a new branch 'hotfix/crash-login'\n    \n    Summary of actions:\n    - A new branch 'hotfix/crash-login' was created, based on 'master'\n    - You are now on branch 'hotfix/crash-login'\n    \n    Follow-up actions:\n    - Start committing your hot fixes\n    - Bump the version number now!\n    - When done, run:\n    \n         git flow hotfix finish 'crash-login'\n\n**完成Hotfix**\n\n    ➜  GitFlow git:(master) git flow hotfix finish crash-login -m \"*bugfix) finish\"\n    Switched to branch 'develop'\n    Merge made by the 'recursive' strategy.\n     GitFlow/ViewController.swift | 1 +\n     1 file changed, 1 insertion(+)\n    Deleted branch hotfix/crash-login (was 1330d0b).\n    \n    Summary of actions:\n    - Hotfix branch 'hotfix/crash-login' has been merged into 'master'\n    - The hotfix was tagged 'crash-login'\n    - Hotfix tag 'crash-login' has been back-merged into 'develop'\n    - Hotfix branch 'hotfix/crash-login' has been locally deleted\n    - You are now on branch 'develop'\n\n\nGit-Flow的hotfix分支和release分支有点像，区别在于release分支是由develop分支拉取出来的新分支，而hotfix分支是由master分支拉取出来的新分支，两者最终都会合并入master和develop分支。只不过hotfix用于生产环境中的紧急修复，需要快速响应和修复，减少Code ReView和QA环节的时间（不是说不做，只是说尽量快点完成这两个环节，尽量快点修复，否则大批用户都会受这个bug影响，毕竟是生产环境。）\n\n##提交commit规范\n\n    feat: 新增feature\n    fix: 修复bug\n    docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\n    style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑\n    refactor: 代码重构，没有加新功能或者修复bug\n    perf: 优化相关，比如提升性能、体验\n    test: 测试用例，包括单元测试、集成测试等\n    chore: 改变构建流程、或者增加依赖库、工具等\n    revert: 回滚到上一个版本\n    \n    eg:\n        git commit -m \"feat： balabalabalaxxxxxxxxxx\"\n        \n        git commit -am \"fix： balabalabalaxxxxxxxxxx\"\n        \n        fix: Add TimeUnit null check test case in Timed #5231\n        * Add TimeUnit null check test case in Timed\n        * Correct ugly formatting in BasicIntQueueDisposable\n        * Reformatting line\n        * Add blockingIterable’s negative buffer size fail  test,close #5232\n        * Modify BlockingMultiObserver field’s modfier to private,fix #5231\n        * Revert style, modifier\n        * Remove duplicated test case.\n        * Remove no need annotation and variable\n\n##使用流程\n\n如果项目之前没有用过需要初始化一下\n\n    git flow init \n\n有新的需求了 \n    \n    git flow feature start order_delete\n\n推到远端 要不队友看不到（如果之前没有的话）\n    \n    git push origin order_delete\n\n修改了xxx\n    \n    git commit -m \"fix: 修复了xxxxx\"\n\n推到远端\n    \n    git push origin order_delete\n\n过了几天 项目开发完成 测试也通过了\n    \n    git flow feature finish order_delete\n\n这时候默认会自动删掉order_delete这个分支 并切换到develop\n\n测试通过 准备发包\n    \n    git flow release start 2.2.5\n\n看看要不要修改版本号什么的。。。 没问题的话\n    \n    git flow release finish 2.2.5\n\n\n---\n\n上线了 发现这个版本有bug需要立即修复\n    \n    git flow hotfix start crashBug\n    \n    git commit -m \"fix: xxxxxx\"\n    \n    git push origin crashBug\n\n再次提测 没问题了就\n    \n    git flow hotfix finish crashBug\n\n测试通过 准备发包\n    \n    git flow release start 2.2.5\n\n看看要不要修改版本号什么的。。。 没问题的话\n    \n    git flow release finish 2.2.5\n\n\n\n\n\n##问题\n\n**feature是否应该细化到一个个小功能？feature与feature之间有耦合怎么处理？**\n\n这个问题可以看具体情况而定\n\n如果产品的需求耦合性不是很高 功能比较独立 这是建议分拆feature\n\n如果需求本身就是相互依赖 这时候分拆feature会适得其反\n\n##总结\n\nGitFlow有5大分支：\nmaster（主干）\ndevelop（开发）\nfeature（功能）\nrelease（预发布）\nhotfix（热修复）\n这里说下release分支，其实正名应该叫发布分支，我为什么叫他预发布分支呢，因为这个release分支并不是真正的发布，他是由develop分支经过多次feature功能迭代后分出来的一个分支，告诉大家这些功能准备的差不多了，可以准备发布了，但是实际上并没有发布。release分支创建好后，应由QA做测试，研发一起联调，然后先发布到测试环境中进行测试，QA如果觉得有问题，可以先提交工单给研发，研发在这个release分支上做小幅度bug修复，如果QA觉得可以使用的时候再由研发完成发布功能，此时release分支上所做的更改会被合并入master和develop分支中,release分支会在合并后被删除\n\n\n##参考\n\n[GitFlow with SourceTree](https://www.jianshu.com/p/8a3988057d0f)\n\n[git-flow 的工作流程](https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow)\n\n","source":"_posts/git-flow.md","raw":"---\ntitle: git-flow\ndate: 2018-05-25 15:01:12\ntags:\n---\n\n\n#git-flow 使用\n\n\n##安装 git-flow\n    \n    brew install git-flow\n\n*要了解安装 git-flow 细节，请阅读下面这个文档 [official documentation](https://github.com/petervanderdoes/gitflow/wiki#installing-git-flow)。*\n\n##在项目中设置 git-flow\n    \n    ➜  GitFlow git:(master) git flow init\n\n    Which branch should be used for bringing forth production releases?\n       - master\n    Branch name for production releases: [master]\n    Branch name for \"next release\" development: [develop]\n    \n    How to name your supporting branch prefixes?\n    Feature branches? [feature/]\n    Bugfix branches? [bugfix/]\n    Release branches? [release/]\n    Hotfix branches? [hotfix/]\n    Support branches? [support/]\n    Version tag prefix? []\n    Hooks and filters directory? [/Users/tonytong/Desktop/GitFlow/.git/hooks\n\n\n##功能开发\n对于一个开发人员来说，最平常的工作可能就是功能的开发。这就是为什么 git-flow 定义了很多对于功能开发的工作流程，从而来帮助你有组织地完成它。\n\n**Feature 开始开发一个新功能**\n    \n\n    ➜  GitFlow git:(develop) git flow feature start test-gitflow\n    Switched to a new branch 'feature/test-gitflow'\n    \n    Summary of actions:\n    - A new branch 'feature/test-gitflow' was created, based on 'develop'\n    - You are now on branch 'feature/test-gitflow'\n    \n    Now, start committing on your feature. When done, use:\n    \n         git flow feature finish test-gitflow\n         \n    \n    上面的 git flow feature start test-gitflow 会基于develop创建一个新的分支test-gitflow 并自动切换到该分支\n\n\n**Feature 完成一个新功能**\n    \n    ➜  GitFlow git:(feature/test-gitflow) git flow feature finish test-gitflow\n    Switched to branch 'develop'\n    Updating 862396e..e367e7c\n    Fast-forward\n     GitFlow/ViewController.swift | 2 ++\n     1 file changed, 2 insertions(+)\n    Deleted branch feature/test-gitflow (was e367e7c).\n    \n    Summary of actions:\n    - The feature branch 'feature/test-gitflow' was merged into 'develop'\n    - Feature branch 'feature/test-gitflow' has been locally deleted\n    - You are now on branch 'develop'\n\n执行feature finish之后会把我们的工作整合到主 “develop” 分支中去 \n而且还会删除这个当下已经完成的功能分支 并且自动切换到 “develop” 分支 \n\n**创建Release**\n\n    ➜  GitFlow git:(develop) git flow release start 1.0.0\n    Switched to a new branch 'release/1.0.0'\n    \n    Summary of actions:\n    - A new branch 'release/1.0.0' was created, based on 'develop'\n    - You are now on branch 'release/1.0.0'\n    \n    Follow-up actions:\n    - Bump the version number now!\n    - Start committing last-minute fixes in preparing your release\n    - When done, run:\n    \n         git flow release finish '1.0.0'\n         \n    \n请注意，release 分支是使用版本号命名的。这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地_自动_去标记那些 release 提交。\n\n有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。\n\n\n         \n**完成Release**\n\n    ➜  GitFlow git:(release/1.0.0) git flow release finish -m \"*release) finish\"\n    Switched to branch 'master'\n    Merge made by the 'recursive' strategy.\n     GitFlow/ViewController.swift | 1 +\n     1 file changed, 1 insertion(+)\n    Already on 'master'\n    Switched to branch 'develop'\n    Already up to date!\n    Merge made by the 'recursive' strategy.\n    Deleted branch release/1.0.0 (was 93ae994).\n    \n    Summary of actions:\n    - Release branch 'release/1.0.0' has been merged into 'master'\n    - The release was tagged '1.0.0'\n    - Release tag '1.0.0' has been back-merged into 'develop'\n    - Release branch 'release/1.0.0' has been locally deleted\n    - You are now on branch 'develop'\n\n\n    这个命令会完成如下一系列的操作：\n\n    1 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。\n    2 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。\n    3 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.0.0”）。\n    4 清理操作，版本分支会被删除，并且回到 “develop”。\n    \n    从 Git 的角度来看，release 版本现在已经完成。依据你的设置，\n    对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，\n    来让你的软件产品进入你的用户手中。\n\n\n**创建Hotfix**\n\n    ➜  GitFlow git:(develop) git flow hotfix start crash-login\n    Switched to a new branch 'hotfix/crash-login'\n    \n    Summary of actions:\n    - A new branch 'hotfix/crash-login' was created, based on 'master'\n    - You are now on branch 'hotfix/crash-login'\n    \n    Follow-up actions:\n    - Start committing your hot fixes\n    - Bump the version number now!\n    - When done, run:\n    \n         git flow hotfix finish 'crash-login'\n\n**完成Hotfix**\n\n    ➜  GitFlow git:(master) git flow hotfix finish crash-login -m \"*bugfix) finish\"\n    Switched to branch 'develop'\n    Merge made by the 'recursive' strategy.\n     GitFlow/ViewController.swift | 1 +\n     1 file changed, 1 insertion(+)\n    Deleted branch hotfix/crash-login (was 1330d0b).\n    \n    Summary of actions:\n    - Hotfix branch 'hotfix/crash-login' has been merged into 'master'\n    - The hotfix was tagged 'crash-login'\n    - Hotfix tag 'crash-login' has been back-merged into 'develop'\n    - Hotfix branch 'hotfix/crash-login' has been locally deleted\n    - You are now on branch 'develop'\n\n\nGit-Flow的hotfix分支和release分支有点像，区别在于release分支是由develop分支拉取出来的新分支，而hotfix分支是由master分支拉取出来的新分支，两者最终都会合并入master和develop分支。只不过hotfix用于生产环境中的紧急修复，需要快速响应和修复，减少Code ReView和QA环节的时间（不是说不做，只是说尽量快点完成这两个环节，尽量快点修复，否则大批用户都会受这个bug影响，毕竟是生产环境。）\n\n##提交commit规范\n\n    feat: 新增feature\n    fix: 修复bug\n    docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\n    style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑\n    refactor: 代码重构，没有加新功能或者修复bug\n    perf: 优化相关，比如提升性能、体验\n    test: 测试用例，包括单元测试、集成测试等\n    chore: 改变构建流程、或者增加依赖库、工具等\n    revert: 回滚到上一个版本\n    \n    eg:\n        git commit -m \"feat： balabalabalaxxxxxxxxxx\"\n        \n        git commit -am \"fix： balabalabalaxxxxxxxxxx\"\n        \n        fix: Add TimeUnit null check test case in Timed #5231\n        * Add TimeUnit null check test case in Timed\n        * Correct ugly formatting in BasicIntQueueDisposable\n        * Reformatting line\n        * Add blockingIterable’s negative buffer size fail  test,close #5232\n        * Modify BlockingMultiObserver field’s modfier to private,fix #5231\n        * Revert style, modifier\n        * Remove duplicated test case.\n        * Remove no need annotation and variable\n\n##使用流程\n\n如果项目之前没有用过需要初始化一下\n\n    git flow init \n\n有新的需求了 \n    \n    git flow feature start order_delete\n\n推到远端 要不队友看不到（如果之前没有的话）\n    \n    git push origin order_delete\n\n修改了xxx\n    \n    git commit -m \"fix: 修复了xxxxx\"\n\n推到远端\n    \n    git push origin order_delete\n\n过了几天 项目开发完成 测试也通过了\n    \n    git flow feature finish order_delete\n\n这时候默认会自动删掉order_delete这个分支 并切换到develop\n\n测试通过 准备发包\n    \n    git flow release start 2.2.5\n\n看看要不要修改版本号什么的。。。 没问题的话\n    \n    git flow release finish 2.2.5\n\n\n---\n\n上线了 发现这个版本有bug需要立即修复\n    \n    git flow hotfix start crashBug\n    \n    git commit -m \"fix: xxxxxx\"\n    \n    git push origin crashBug\n\n再次提测 没问题了就\n    \n    git flow hotfix finish crashBug\n\n测试通过 准备发包\n    \n    git flow release start 2.2.5\n\n看看要不要修改版本号什么的。。。 没问题的话\n    \n    git flow release finish 2.2.5\n\n\n\n\n\n##问题\n\n**feature是否应该细化到一个个小功能？feature与feature之间有耦合怎么处理？**\n\n这个问题可以看具体情况而定\n\n如果产品的需求耦合性不是很高 功能比较独立 这是建议分拆feature\n\n如果需求本身就是相互依赖 这时候分拆feature会适得其反\n\n##总结\n\nGitFlow有5大分支：\nmaster（主干）\ndevelop（开发）\nfeature（功能）\nrelease（预发布）\nhotfix（热修复）\n这里说下release分支，其实正名应该叫发布分支，我为什么叫他预发布分支呢，因为这个release分支并不是真正的发布，他是由develop分支经过多次feature功能迭代后分出来的一个分支，告诉大家这些功能准备的差不多了，可以准备发布了，但是实际上并没有发布。release分支创建好后，应由QA做测试，研发一起联调，然后先发布到测试环境中进行测试，QA如果觉得有问题，可以先提交工单给研发，研发在这个release分支上做小幅度bug修复，如果QA觉得可以使用的时候再由研发完成发布功能，此时release分支上所做的更改会被合并入master和develop分支中,release分支会在合并后被删除\n\n\n##参考\n\n[GitFlow with SourceTree](https://www.jianshu.com/p/8a3988057d0f)\n\n[git-flow 的工作流程](https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow)\n\n","slug":"git-flow","published":1,"updated":"2019-08-14T13:31:03.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzbbi8i60003aq1k1oklg4df","content":"<p>#git-flow 使用</p>\n<p>##安装 git-flow</p>\n<pre><code>brew install git-flow\n</code></pre><p><em>要了解安装 git-flow 细节，请阅读下面这个文档 <a href=\"https://github.com/petervanderdoes/gitflow/wiki#installing-git-flow\" target=\"_blank\" rel=\"external\">official documentation</a>。</em></p>\n<p>##在项目中设置 git-flow</p>\n<pre><code>➜  GitFlow git:(master) git flow init\n\nWhich branch should be used for bringing forth production releases?\n   - master\nBranch name for production releases: [master]\nBranch name for &quot;next release&quot; development: [develop]\n\nHow to name your supporting branch prefixes?\nFeature branches? [feature/]\nBugfix branches? [bugfix/]\nRelease branches? [release/]\nHotfix branches? [hotfix/]\nSupport branches? [support/]\nVersion tag prefix? []\nHooks and filters directory? [/Users/tonytong/Desktop/GitFlow/.git/hooks\n</code></pre><p>##功能开发<br>对于一个开发人员来说，最平常的工作可能就是功能的开发。这就是为什么 git-flow 定义了很多对于功能开发的工作流程，从而来帮助你有组织地完成它。</p>\n<p><strong>Feature 开始开发一个新功能</strong></p>\n<pre><code>➜  GitFlow git:(develop) git flow feature start test-gitflow\nSwitched to a new branch &apos;feature/test-gitflow&apos;\n\nSummary of actions:\n- A new branch &apos;feature/test-gitflow&apos; was created, based on &apos;develop&apos;\n- You are now on branch &apos;feature/test-gitflow&apos;\n\nNow, start committing on your feature. When done, use:\n\n     git flow feature finish test-gitflow\n\n\n上面的 git flow feature start test-gitflow 会基于develop创建一个新的分支test-gitflow 并自动切换到该分支\n</code></pre><p><strong>Feature 完成一个新功能</strong></p>\n<pre><code>➜  GitFlow git:(feature/test-gitflow) git flow feature finish test-gitflow\nSwitched to branch &apos;develop&apos;\nUpdating 862396e..e367e7c\nFast-forward\n GitFlow/ViewController.swift | 2 ++\n 1 file changed, 2 insertions(+)\nDeleted branch feature/test-gitflow (was e367e7c).\n\nSummary of actions:\n- The feature branch &apos;feature/test-gitflow&apos; was merged into &apos;develop&apos;\n- Feature branch &apos;feature/test-gitflow&apos; has been locally deleted\n- You are now on branch &apos;develop&apos;\n</code></pre><p>执行feature finish之后会把我们的工作整合到主 “develop” 分支中去<br>而且还会删除这个当下已经完成的功能分支 并且自动切换到 “develop” 分支 </p>\n<p><strong>创建Release</strong></p>\n<pre><code>➜  GitFlow git:(develop) git flow release start 1.0.0\nSwitched to a new branch &apos;release/1.0.0&apos;\n\nSummary of actions:\n- A new branch &apos;release/1.0.0&apos; was created, based on &apos;develop&apos;\n- You are now on branch &apos;release/1.0.0&apos;\n\nFollow-up actions:\n- Bump the version number now!\n- Start committing last-minute fixes in preparing your release\n- When done, run:\n\n     git flow release finish &apos;1.0.0&apos;\n</code></pre><p>请注意，release 分支是使用版本号命名的。这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地<em>自动</em>去标记那些 release 提交。</p>\n<p>有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。</p>\n<p><strong>完成Release</strong></p>\n<pre><code>➜  GitFlow git:(release/1.0.0) git flow release finish -m &quot;*release) finish&quot;\nSwitched to branch &apos;master&apos;\nMerge made by the &apos;recursive&apos; strategy.\n GitFlow/ViewController.swift | 1 +\n 1 file changed, 1 insertion(+)\nAlready on &apos;master&apos;\nSwitched to branch &apos;develop&apos;\nAlready up to date!\nMerge made by the &apos;recursive&apos; strategy.\nDeleted branch release/1.0.0 (was 93ae994).\n\nSummary of actions:\n- Release branch &apos;release/1.0.0&apos; has been merged into &apos;master&apos;\n- The release was tagged &apos;1.0.0&apos;\n- Release tag &apos;1.0.0&apos; has been back-merged into &apos;develop&apos;\n- Release branch &apos;release/1.0.0&apos; has been locally deleted\n- You are now on branch &apos;develop&apos;\n\n\n这个命令会完成如下一系列的操作：\n\n1 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。\n2 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。\n3 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.0.0”）。\n4 清理操作，版本分支会被删除，并且回到 “develop”。\n\n从 Git 的角度来看，release 版本现在已经完成。依据你的设置，\n对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，\n来让你的软件产品进入你的用户手中。\n</code></pre><p><strong>创建Hotfix</strong></p>\n<pre><code>➜  GitFlow git:(develop) git flow hotfix start crash-login\nSwitched to a new branch &apos;hotfix/crash-login&apos;\n\nSummary of actions:\n- A new branch &apos;hotfix/crash-login&apos; was created, based on &apos;master&apos;\n- You are now on branch &apos;hotfix/crash-login&apos;\n\nFollow-up actions:\n- Start committing your hot fixes\n- Bump the version number now!\n- When done, run:\n\n     git flow hotfix finish &apos;crash-login&apos;\n</code></pre><p><strong>完成Hotfix</strong></p>\n<pre><code>➜  GitFlow git:(master) git flow hotfix finish crash-login -m &quot;*bugfix) finish&quot;\nSwitched to branch &apos;develop&apos;\nMerge made by the &apos;recursive&apos; strategy.\n GitFlow/ViewController.swift | 1 +\n 1 file changed, 1 insertion(+)\nDeleted branch hotfix/crash-login (was 1330d0b).\n\nSummary of actions:\n- Hotfix branch &apos;hotfix/crash-login&apos; has been merged into &apos;master&apos;\n- The hotfix was tagged &apos;crash-login&apos;\n- Hotfix tag &apos;crash-login&apos; has been back-merged into &apos;develop&apos;\n- Hotfix branch &apos;hotfix/crash-login&apos; has been locally deleted\n- You are now on branch &apos;develop&apos;\n</code></pre><p>Git-Flow的hotfix分支和release分支有点像，区别在于release分支是由develop分支拉取出来的新分支，而hotfix分支是由master分支拉取出来的新分支，两者最终都会合并入master和develop分支。只不过hotfix用于生产环境中的紧急修复，需要快速响应和修复，减少Code ReView和QA环节的时间（不是说不做，只是说尽量快点完成这两个环节，尽量快点修复，否则大批用户都会受这个bug影响，毕竟是生产环境。）</p>\n<p>##提交commit规范</p>\n<pre><code>feat: 新增feature\nfix: 修复bug\ndocs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\nstyle: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑\nrefactor: 代码重构，没有加新功能或者修复bug\nperf: 优化相关，比如提升性能、体验\ntest: 测试用例，包括单元测试、集成测试等\nchore: 改变构建流程、或者增加依赖库、工具等\nrevert: 回滚到上一个版本\n\neg:\n    git commit -m &quot;feat： balabalabalaxxxxxxxxxx&quot;\n\n    git commit -am &quot;fix： balabalabalaxxxxxxxxxx&quot;\n\n    fix: Add TimeUnit null check test case in Timed #5231\n    * Add TimeUnit null check test case in Timed\n    * Correct ugly formatting in BasicIntQueueDisposable\n    * Reformatting line\n    * Add blockingIterable’s negative buffer size fail  test,close #5232\n    * Modify BlockingMultiObserver field’s modfier to private,fix #5231\n    * Revert style, modifier\n    * Remove duplicated test case.\n    * Remove no need annotation and variable\n</code></pre><p>##使用流程</p>\n<p>如果项目之前没有用过需要初始化一下</p>\n<pre><code>git flow init \n</code></pre><p>有新的需求了 </p>\n<pre><code>git flow feature start order_delete\n</code></pre><p>推到远端 要不队友看不到（如果之前没有的话）</p>\n<pre><code>git push origin order_delete\n</code></pre><p>修改了xxx</p>\n<pre><code>git commit -m &quot;fix: 修复了xxxxx&quot;\n</code></pre><p>推到远端</p>\n<pre><code>git push origin order_delete\n</code></pre><p>过了几天 项目开发完成 测试也通过了</p>\n<pre><code>git flow feature finish order_delete\n</code></pre><p>这时候默认会自动删掉order_delete这个分支 并切换到develop</p>\n<p>测试通过 准备发包</p>\n<pre><code>git flow release start 2.2.5\n</code></pre><p>看看要不要修改版本号什么的。。。 没问题的话</p>\n<pre><code>git flow release finish 2.2.5\n</code></pre><hr>\n<p>上线了 发现这个版本有bug需要立即修复</p>\n<pre><code>git flow hotfix start crashBug\n\ngit commit -m &quot;fix: xxxxxx&quot;\n\ngit push origin crashBug\n</code></pre><p>再次提测 没问题了就</p>\n<pre><code>git flow hotfix finish crashBug\n</code></pre><p>测试通过 准备发包</p>\n<pre><code>git flow release start 2.2.5\n</code></pre><p>看看要不要修改版本号什么的。。。 没问题的话</p>\n<pre><code>git flow release finish 2.2.5\n</code></pre><p>##问题</p>\n<p><strong>feature是否应该细化到一个个小功能？feature与feature之间有耦合怎么处理？</strong></p>\n<p>这个问题可以看具体情况而定</p>\n<p>如果产品的需求耦合性不是很高 功能比较独立 这是建议分拆feature</p>\n<p>如果需求本身就是相互依赖 这时候分拆feature会适得其反</p>\n<p>##总结</p>\n<p>GitFlow有5大分支：<br>master（主干）<br>develop（开发）<br>feature（功能）<br>release（预发布）<br>hotfix（热修复）<br>这里说下release分支，其实正名应该叫发布分支，我为什么叫他预发布分支呢，因为这个release分支并不是真正的发布，他是由develop分支经过多次feature功能迭代后分出来的一个分支，告诉大家这些功能准备的差不多了，可以准备发布了，但是实际上并没有发布。release分支创建好后，应由QA做测试，研发一起联调，然后先发布到测试环境中进行测试，QA如果觉得有问题，可以先提交工单给研发，研发在这个release分支上做小幅度bug修复，如果QA觉得可以使用的时候再由研发完成发布功能，此时release分支上所做的更改会被合并入master和develop分支中,release分支会在合并后被删除</p>\n<p>##参考</p>\n<p><a href=\"https://www.jianshu.com/p/8a3988057d0f\" target=\"_blank\" rel=\"external\">GitFlow with SourceTree</a></p>\n<p><a href=\"https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow\" target=\"_blank\" rel=\"external\">git-flow 的工作流程</a></p>\n","excerpt":"","more":"<p>#git-flow 使用</p>\n<p>##安装 git-flow</p>\n<pre><code>brew install git-flow\n</code></pre><p><em>要了解安装 git-flow 细节，请阅读下面这个文档 <a href=\"https://github.com/petervanderdoes/gitflow/wiki#installing-git-flow\">official documentation</a>。</em></p>\n<p>##在项目中设置 git-flow</p>\n<pre><code>➜  GitFlow git:(master) git flow init\n\nWhich branch should be used for bringing forth production releases?\n   - master\nBranch name for production releases: [master]\nBranch name for &quot;next release&quot; development: [develop]\n\nHow to name your supporting branch prefixes?\nFeature branches? [feature/]\nBugfix branches? [bugfix/]\nRelease branches? [release/]\nHotfix branches? [hotfix/]\nSupport branches? [support/]\nVersion tag prefix? []\nHooks and filters directory? [/Users/tonytong/Desktop/GitFlow/.git/hooks\n</code></pre><p>##功能开发<br>对于一个开发人员来说，最平常的工作可能就是功能的开发。这就是为什么 git-flow 定义了很多对于功能开发的工作流程，从而来帮助你有组织地完成它。</p>\n<p><strong>Feature 开始开发一个新功能</strong></p>\n<pre><code>➜  GitFlow git:(develop) git flow feature start test-gitflow\nSwitched to a new branch &apos;feature/test-gitflow&apos;\n\nSummary of actions:\n- A new branch &apos;feature/test-gitflow&apos; was created, based on &apos;develop&apos;\n- You are now on branch &apos;feature/test-gitflow&apos;\n\nNow, start committing on your feature. When done, use:\n\n     git flow feature finish test-gitflow\n\n\n上面的 git flow feature start test-gitflow 会基于develop创建一个新的分支test-gitflow 并自动切换到该分支\n</code></pre><p><strong>Feature 完成一个新功能</strong></p>\n<pre><code>➜  GitFlow git:(feature/test-gitflow) git flow feature finish test-gitflow\nSwitched to branch &apos;develop&apos;\nUpdating 862396e..e367e7c\nFast-forward\n GitFlow/ViewController.swift | 2 ++\n 1 file changed, 2 insertions(+)\nDeleted branch feature/test-gitflow (was e367e7c).\n\nSummary of actions:\n- The feature branch &apos;feature/test-gitflow&apos; was merged into &apos;develop&apos;\n- Feature branch &apos;feature/test-gitflow&apos; has been locally deleted\n- You are now on branch &apos;develop&apos;\n</code></pre><p>执行feature finish之后会把我们的工作整合到主 “develop” 分支中去<br>而且还会删除这个当下已经完成的功能分支 并且自动切换到 “develop” 分支 </p>\n<p><strong>创建Release</strong></p>\n<pre><code>➜  GitFlow git:(develop) git flow release start 1.0.0\nSwitched to a new branch &apos;release/1.0.0&apos;\n\nSummary of actions:\n- A new branch &apos;release/1.0.0&apos; was created, based on &apos;develop&apos;\n- You are now on branch &apos;release/1.0.0&apos;\n\nFollow-up actions:\n- Bump the version number now!\n- Start committing last-minute fixes in preparing your release\n- When done, run:\n\n     git flow release finish &apos;1.0.0&apos;\n</code></pre><p>请注意，release 分支是使用版本号命名的。这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地<em>自动</em>去标记那些 release 提交。</p>\n<p>有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。</p>\n<p><strong>完成Release</strong></p>\n<pre><code>➜  GitFlow git:(release/1.0.0) git flow release finish -m &quot;*release) finish&quot;\nSwitched to branch &apos;master&apos;\nMerge made by the &apos;recursive&apos; strategy.\n GitFlow/ViewController.swift | 1 +\n 1 file changed, 1 insertion(+)\nAlready on &apos;master&apos;\nSwitched to branch &apos;develop&apos;\nAlready up to date!\nMerge made by the &apos;recursive&apos; strategy.\nDeleted branch release/1.0.0 (was 93ae994).\n\nSummary of actions:\n- Release branch &apos;release/1.0.0&apos; has been merged into &apos;master&apos;\n- The release was tagged &apos;1.0.0&apos;\n- Release tag &apos;1.0.0&apos; has been back-merged into &apos;develop&apos;\n- Release branch &apos;release/1.0.0&apos; has been locally deleted\n- You are now on branch &apos;develop&apos;\n\n\n这个命令会完成如下一系列的操作：\n\n1 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。\n2 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。\n3 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.0.0”）。\n4 清理操作，版本分支会被删除，并且回到 “develop”。\n\n从 Git 的角度来看，release 版本现在已经完成。依据你的设置，\n对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，\n来让你的软件产品进入你的用户手中。\n</code></pre><p><strong>创建Hotfix</strong></p>\n<pre><code>➜  GitFlow git:(develop) git flow hotfix start crash-login\nSwitched to a new branch &apos;hotfix/crash-login&apos;\n\nSummary of actions:\n- A new branch &apos;hotfix/crash-login&apos; was created, based on &apos;master&apos;\n- You are now on branch &apos;hotfix/crash-login&apos;\n\nFollow-up actions:\n- Start committing your hot fixes\n- Bump the version number now!\n- When done, run:\n\n     git flow hotfix finish &apos;crash-login&apos;\n</code></pre><p><strong>完成Hotfix</strong></p>\n<pre><code>➜  GitFlow git:(master) git flow hotfix finish crash-login -m &quot;*bugfix) finish&quot;\nSwitched to branch &apos;develop&apos;\nMerge made by the &apos;recursive&apos; strategy.\n GitFlow/ViewController.swift | 1 +\n 1 file changed, 1 insertion(+)\nDeleted branch hotfix/crash-login (was 1330d0b).\n\nSummary of actions:\n- Hotfix branch &apos;hotfix/crash-login&apos; has been merged into &apos;master&apos;\n- The hotfix was tagged &apos;crash-login&apos;\n- Hotfix tag &apos;crash-login&apos; has been back-merged into &apos;develop&apos;\n- Hotfix branch &apos;hotfix/crash-login&apos; has been locally deleted\n- You are now on branch &apos;develop&apos;\n</code></pre><p>Git-Flow的hotfix分支和release分支有点像，区别在于release分支是由develop分支拉取出来的新分支，而hotfix分支是由master分支拉取出来的新分支，两者最终都会合并入master和develop分支。只不过hotfix用于生产环境中的紧急修复，需要快速响应和修复，减少Code ReView和QA环节的时间（不是说不做，只是说尽量快点完成这两个环节，尽量快点修复，否则大批用户都会受这个bug影响，毕竟是生产环境。）</p>\n<p>##提交commit规范</p>\n<pre><code>feat: 新增feature\nfix: 修复bug\ndocs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\nstyle: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑\nrefactor: 代码重构，没有加新功能或者修复bug\nperf: 优化相关，比如提升性能、体验\ntest: 测试用例，包括单元测试、集成测试等\nchore: 改变构建流程、或者增加依赖库、工具等\nrevert: 回滚到上一个版本\n\neg:\n    git commit -m &quot;feat： balabalabalaxxxxxxxxxx&quot;\n\n    git commit -am &quot;fix： balabalabalaxxxxxxxxxx&quot;\n\n    fix: Add TimeUnit null check test case in Timed #5231\n    * Add TimeUnit null check test case in Timed\n    * Correct ugly formatting in BasicIntQueueDisposable\n    * Reformatting line\n    * Add blockingIterable’s negative buffer size fail  test,close #5232\n    * Modify BlockingMultiObserver field’s modfier to private,fix #5231\n    * Revert style, modifier\n    * Remove duplicated test case.\n    * Remove no need annotation and variable\n</code></pre><p>##使用流程</p>\n<p>如果项目之前没有用过需要初始化一下</p>\n<pre><code>git flow init \n</code></pre><p>有新的需求了 </p>\n<pre><code>git flow feature start order_delete\n</code></pre><p>推到远端 要不队友看不到（如果之前没有的话）</p>\n<pre><code>git push origin order_delete\n</code></pre><p>修改了xxx</p>\n<pre><code>git commit -m &quot;fix: 修复了xxxxx&quot;\n</code></pre><p>推到远端</p>\n<pre><code>git push origin order_delete\n</code></pre><p>过了几天 项目开发完成 测试也通过了</p>\n<pre><code>git flow feature finish order_delete\n</code></pre><p>这时候默认会自动删掉order_delete这个分支 并切换到develop</p>\n<p>测试通过 准备发包</p>\n<pre><code>git flow release start 2.2.5\n</code></pre><p>看看要不要修改版本号什么的。。。 没问题的话</p>\n<pre><code>git flow release finish 2.2.5\n</code></pre><hr>\n<p>上线了 发现这个版本有bug需要立即修复</p>\n<pre><code>git flow hotfix start crashBug\n\ngit commit -m &quot;fix: xxxxxx&quot;\n\ngit push origin crashBug\n</code></pre><p>再次提测 没问题了就</p>\n<pre><code>git flow hotfix finish crashBug\n</code></pre><p>测试通过 准备发包</p>\n<pre><code>git flow release start 2.2.5\n</code></pre><p>看看要不要修改版本号什么的。。。 没问题的话</p>\n<pre><code>git flow release finish 2.2.5\n</code></pre><p>##问题</p>\n<p><strong>feature是否应该细化到一个个小功能？feature与feature之间有耦合怎么处理？</strong></p>\n<p>这个问题可以看具体情况而定</p>\n<p>如果产品的需求耦合性不是很高 功能比较独立 这是建议分拆feature</p>\n<p>如果需求本身就是相互依赖 这时候分拆feature会适得其反</p>\n<p>##总结</p>\n<p>GitFlow有5大分支：<br>master（主干）<br>develop（开发）<br>feature（功能）<br>release（预发布）<br>hotfix（热修复）<br>这里说下release分支，其实正名应该叫发布分支，我为什么叫他预发布分支呢，因为这个release分支并不是真正的发布，他是由develop分支经过多次feature功能迭代后分出来的一个分支，告诉大家这些功能准备的差不多了，可以准备发布了，但是实际上并没有发布。release分支创建好后，应由QA做测试，研发一起联调，然后先发布到测试环境中进行测试，QA如果觉得有问题，可以先提交工单给研发，研发在这个release分支上做小幅度bug修复，如果QA觉得可以使用的时候再由研发完成发布功能，此时release分支上所做的更改会被合并入master和develop分支中,release分支会在合并后被删除</p>\n<p>##参考</p>\n<p><a href=\"https://www.jianshu.com/p/8a3988057d0f\">GitFlow with SourceTree</a></p>\n<p><a href=\"https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow\">git-flow 的工作流程</a></p>\n"},{"title":"新Mac 记一次修改shadowsocks过程","date":"2016-08-25T10:29:55.000Z","_content":">  **记住 确认是否已经登录服务器了 以下操作基本都是基于登录状态** \n\n### 1.使用ssh生成秘钥\n\n\n     ssh-keygen -t rsa -C \"your_email@example.com\"\n     \n     \n* 然后会提示输入密钥的名字 比如输入 oktang\n* 注意要避免重复命名\n* 还要求输入私钥密码 password\n\n### 2.配置本地ssh登录 需要修改config文件 添加服务器 用户名和端口信息\n\n     Host vultr\n          HostName 0.0.0.0 //自己的服务器地址\n          User user  //服务器用户名\n          Port 1080  //连接服务器的端口\n          IdentityFile ~/.ssh/oktang //私钥路径\n\n### 3.将这个公钥*oktang.pub*添加到服务器上的authorization.keys中\n     \n* authorization.keys这个文件如果没有就新生成一个\n* 使用ssh登录到服务器\n\t\t\n\t\tssh oktang\n\t\t cd ~/.ssh\n\t     vi authorized_keys\n\t    \n* 将之前生成的公钥内容拷贝到authorized_keys中\n* ok\n\n### 4.如果需要修改端口 使用ssh登录服务器\n\n修改shadow socks中的端口 或者密码什么的\n\n    vi /etc/shadowsocks.json\n    \n    单一账号配置\n     {\n         \"server\":\"0.0.0.0”, //这里不用绑定你的服务器\n         \"server_port”:port, //这个是shadow socks端口 到时候客户端需要用的\n         \"local_address\": \"127.0.0.1\",\n         \"local_port\":1080,\n         \"password”:\"password”,//shadowsocks密码\n         \"timeout\":300,\n         \"method\":\"aes-256-cfb\",\n         \"fast_open\": false\n     }\n     \n     多账号配置\n     {\n         \"server\":\"0.0.0.0\", //这里不用绑定你的服务器\n         \"local_address\": \"127.0.0.1\",\n         \"local_port\":1080,\n         \"port_password\":{\n            \"port1\":\"password1\",\n            \"port2\":\"password2\",\n            \"port3\":\"password3\"\n         },\n         \"timeout\":300,\n         \"method\":\"aes-256-cfb\",\n         \"fast_open\": false\n     }\n* 修改“server_port”:12345 即可\n\n* 修改登录端口\n\n\t\tcd /etc/ssh\n\t\t\n\t     vi sshd_config \n\t    \n* 修改sshd_config中的Port端口 这个端口需要和ssh登录的端口一致 如果不一致ssh将会登录不了\n\n\n### 5.配置完成后 可以添加shadowsocks环境\n\n\n#### ** 在已经登录服务器的情况下 执行 **\n\n\n\n\t\tsudo pip install shadowsocks\n\t\n\n** 在没有/etc/shadowsocks.json配置文件的情况下  **\n\n\t\tssserver -h //查看所有参数\n\n\t\t ssserver -p 443 -k password -m aes-256-cfb //前台运行，443为服务器端口，password为密码，修改这两项即可\n\n\t\t sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start //后台运行方法，修改同上\n\n\t\t sudo ssserver -d stop //停止运行\n\n\t\t sudo less /var/log/shadowsocks.log //检查日志\n\t\n** vi /etc/shadowsocks.json **\n\t\n\t{\n\t    \"server\":\"my_server_ip\",\n\t    \"server_port\":8388,\n\t    \"local_address\": \"127.0.0.1\",\n\t    \"local_port\":1080,\n\t    \"password\":\"mypassword\",\n\t    \"timeout\":300,\n\t    \"method\":\"aes-256-cfb\",\n\t    \"fast_open\": false\n    }\n\t    \n\t\tssserver -c /etc/shadowsocks.json //前台运行\n\n\t\tssserver -c /etc/shadowsocks.json -d start //后台运行\n\n\t\tssserver -c /etc/shadowsocks.json -d stop //停止\n\n\n### 6 几项检查命令 和一些error\n\t netstat -antpl|grep -i listen //查看服务器运行状态\n\n\t  chmod 600 ~/.ssh/authorized_keys //记住要设置文件为可读可写rw\n\t\n      ll ~/.ssh //查看文件的权限\n\t\n **[Error 98] Address already in use**\n \n\t 这个error应该是端口被占用了 修改shadowsocks.json中的端口\n\t \n\t  切记shadowsocks.json中的端口不要和ssh登录端口一样 这是不一样的\n\t \n**Permission denied(publishkey,gssapi-keyex,gssapi-with-mic)**\n\n\t使用ssh登录服务器报错 这个错误是公钥没有添加在authorized_keys中 \n\t\n     加进去就行\n\n### 7 如果以上都成功了 还不能翻墙 \n    请先检查一下自己是否开启了shadowsocks翻墙了 如果有关掉 然后重试\n     玩的开心\n     WTF GFW\n\n     \n### 2017-10-09 更新\n之前的东京服务器被封了 于是又购买了一个新加坡的 遇到个小坑 CentOS 7 需要开放防火墙 shadowsocks 服务端口，检查 VPS 供应商是设置的 iptables 还是 firewall，我的是 firewall，所以需要添加一条，然后重新加载一下就好了：\n        \n    firewall-cmd --permanent --add-port=8388/tcp //8388改成自己设置的端口号\n     firewall-cmd --reload\n\n将端口改成自己配置的端口，也就是上面的8388\n\n最后，启动ShadowSocks服务即可\n\n    ssserver -c /etc/shadowsocks.json -d restart\n\n\n","source":"_posts/新Mac-记一次修改shadowsocks过程.md","raw":"---\ntitle: 新Mac 记一次修改shadowsocks过程\ndate: 2016-08-25 18:29:55\ntags: shadowsocks\n---\n>  **记住 确认是否已经登录服务器了 以下操作基本都是基于登录状态** \n\n### 1.使用ssh生成秘钥\n\n\n     ssh-keygen -t rsa -C \"your_email@example.com\"\n     \n     \n* 然后会提示输入密钥的名字 比如输入 oktang\n* 注意要避免重复命名\n* 还要求输入私钥密码 password\n\n### 2.配置本地ssh登录 需要修改config文件 添加服务器 用户名和端口信息\n\n     Host vultr\n          HostName 0.0.0.0 //自己的服务器地址\n          User user  //服务器用户名\n          Port 1080  //连接服务器的端口\n          IdentityFile ~/.ssh/oktang //私钥路径\n\n### 3.将这个公钥*oktang.pub*添加到服务器上的authorization.keys中\n     \n* authorization.keys这个文件如果没有就新生成一个\n* 使用ssh登录到服务器\n\t\t\n\t\tssh oktang\n\t\t cd ~/.ssh\n\t     vi authorized_keys\n\t    \n* 将之前生成的公钥内容拷贝到authorized_keys中\n* ok\n\n### 4.如果需要修改端口 使用ssh登录服务器\n\n修改shadow socks中的端口 或者密码什么的\n\n    vi /etc/shadowsocks.json\n    \n    单一账号配置\n     {\n         \"server\":\"0.0.0.0”, //这里不用绑定你的服务器\n         \"server_port”:port, //这个是shadow socks端口 到时候客户端需要用的\n         \"local_address\": \"127.0.0.1\",\n         \"local_port\":1080,\n         \"password”:\"password”,//shadowsocks密码\n         \"timeout\":300,\n         \"method\":\"aes-256-cfb\",\n         \"fast_open\": false\n     }\n     \n     多账号配置\n     {\n         \"server\":\"0.0.0.0\", //这里不用绑定你的服务器\n         \"local_address\": \"127.0.0.1\",\n         \"local_port\":1080,\n         \"port_password\":{\n            \"port1\":\"password1\",\n            \"port2\":\"password2\",\n            \"port3\":\"password3\"\n         },\n         \"timeout\":300,\n         \"method\":\"aes-256-cfb\",\n         \"fast_open\": false\n     }\n* 修改“server_port”:12345 即可\n\n* 修改登录端口\n\n\t\tcd /etc/ssh\n\t\t\n\t     vi sshd_config \n\t    \n* 修改sshd_config中的Port端口 这个端口需要和ssh登录的端口一致 如果不一致ssh将会登录不了\n\n\n### 5.配置完成后 可以添加shadowsocks环境\n\n\n#### ** 在已经登录服务器的情况下 执行 **\n\n\n\n\t\tsudo pip install shadowsocks\n\t\n\n** 在没有/etc/shadowsocks.json配置文件的情况下  **\n\n\t\tssserver -h //查看所有参数\n\n\t\t ssserver -p 443 -k password -m aes-256-cfb //前台运行，443为服务器端口，password为密码，修改这两项即可\n\n\t\t sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start //后台运行方法，修改同上\n\n\t\t sudo ssserver -d stop //停止运行\n\n\t\t sudo less /var/log/shadowsocks.log //检查日志\n\t\n** vi /etc/shadowsocks.json **\n\t\n\t{\n\t    \"server\":\"my_server_ip\",\n\t    \"server_port\":8388,\n\t    \"local_address\": \"127.0.0.1\",\n\t    \"local_port\":1080,\n\t    \"password\":\"mypassword\",\n\t    \"timeout\":300,\n\t    \"method\":\"aes-256-cfb\",\n\t    \"fast_open\": false\n    }\n\t    \n\t\tssserver -c /etc/shadowsocks.json //前台运行\n\n\t\tssserver -c /etc/shadowsocks.json -d start //后台运行\n\n\t\tssserver -c /etc/shadowsocks.json -d stop //停止\n\n\n### 6 几项检查命令 和一些error\n\t netstat -antpl|grep -i listen //查看服务器运行状态\n\n\t  chmod 600 ~/.ssh/authorized_keys //记住要设置文件为可读可写rw\n\t\n      ll ~/.ssh //查看文件的权限\n\t\n **[Error 98] Address already in use**\n \n\t 这个error应该是端口被占用了 修改shadowsocks.json中的端口\n\t \n\t  切记shadowsocks.json中的端口不要和ssh登录端口一样 这是不一样的\n\t \n**Permission denied(publishkey,gssapi-keyex,gssapi-with-mic)**\n\n\t使用ssh登录服务器报错 这个错误是公钥没有添加在authorized_keys中 \n\t\n     加进去就行\n\n### 7 如果以上都成功了 还不能翻墙 \n    请先检查一下自己是否开启了shadowsocks翻墙了 如果有关掉 然后重试\n     玩的开心\n     WTF GFW\n\n     \n### 2017-10-09 更新\n之前的东京服务器被封了 于是又购买了一个新加坡的 遇到个小坑 CentOS 7 需要开放防火墙 shadowsocks 服务端口，检查 VPS 供应商是设置的 iptables 还是 firewall，我的是 firewall，所以需要添加一条，然后重新加载一下就好了：\n        \n    firewall-cmd --permanent --add-port=8388/tcp //8388改成自己设置的端口号\n     firewall-cmd --reload\n\n将端口改成自己配置的端口，也就是上面的8388\n\n最后，启动ShadowSocks服务即可\n\n    ssserver -c /etc/shadowsocks.json -d restart\n\n\n","slug":"新Mac-记一次修改shadowsocks过程","published":1,"updated":"2019-08-14T13:31:03.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzbbi8i70004aq1ke3iwdapo","content":"<blockquote>\n<p> <strong>记住 确认是否已经登录服务器了 以下操作基本都是基于登录状态</strong> </p>\n</blockquote>\n<h3 id=\"1-使用ssh生成秘钥\"><a href=\"#1-使用ssh生成秘钥\" class=\"headerlink\" title=\"1.使用ssh生成秘钥\"></a>1.使用ssh生成秘钥</h3><pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n</code></pre><ul>\n<li>然后会提示输入密钥的名字 比如输入 oktang</li>\n<li>注意要避免重复命名</li>\n<li>还要求输入私钥密码 password</li>\n</ul>\n<h3 id=\"2-配置本地ssh登录-需要修改config文件-添加服务器-用户名和端口信息\"><a href=\"#2-配置本地ssh登录-需要修改config文件-添加服务器-用户名和端口信息\" class=\"headerlink\" title=\"2.配置本地ssh登录 需要修改config文件 添加服务器 用户名和端口信息\"></a>2.配置本地ssh登录 需要修改config文件 添加服务器 用户名和端口信息</h3><pre><code>Host vultr\n     HostName 0.0.0.0 //自己的服务器地址\n     User user  //服务器用户名\n     Port 1080  //连接服务器的端口\n     IdentityFile ~/.ssh/oktang //私钥路径\n</code></pre><h3 id=\"3-将这个公钥oktang-pub添加到服务器上的authorization-keys中\"><a href=\"#3-将这个公钥oktang-pub添加到服务器上的authorization-keys中\" class=\"headerlink\" title=\"3.将这个公钥oktang.pub添加到服务器上的authorization.keys中\"></a>3.将这个公钥<em>oktang.pub</em>添加到服务器上的authorization.keys中</h3><ul>\n<li>authorization.keys这个文件如果没有就新生成一个</li>\n<li><p>使用ssh登录到服务器</p>\n<pre><code>ssh oktang\n cd ~/.ssh\n vi authorized_keys\n</code></pre></li>\n<li><p>将之前生成的公钥内容拷贝到authorized_keys中</p>\n</li>\n<li>ok</li>\n</ul>\n<h3 id=\"4-如果需要修改端口-使用ssh登录服务器\"><a href=\"#4-如果需要修改端口-使用ssh登录服务器\" class=\"headerlink\" title=\"4.如果需要修改端口 使用ssh登录服务器\"></a>4.如果需要修改端口 使用ssh登录服务器</h3><p>修改shadow socks中的端口 或者密码什么的</p>\n<pre><code>vi /etc/shadowsocks.json\n\n单一账号配置\n {\n     &quot;server&quot;:&quot;0.0.0.0”, //这里不用绑定你的服务器\n     &quot;server_port”:port, //这个是shadow socks端口 到时候客户端需要用的\n     &quot;local_address&quot;: &quot;127.0.0.1&quot;,\n     &quot;local_port&quot;:1080,\n     &quot;password”:&quot;password”,//shadowsocks密码\n     &quot;timeout&quot;:300,\n     &quot;method&quot;:&quot;aes-256-cfb&quot;,\n     &quot;fast_open&quot;: false\n }\n\n 多账号配置\n {\n     &quot;server&quot;:&quot;0.0.0.0&quot;, //这里不用绑定你的服务器\n     &quot;local_address&quot;: &quot;127.0.0.1&quot;,\n     &quot;local_port&quot;:1080,\n     &quot;port_password&quot;:{\n        &quot;port1&quot;:&quot;password1&quot;,\n        &quot;port2&quot;:&quot;password2&quot;,\n        &quot;port3&quot;:&quot;password3&quot;\n     },\n     &quot;timeout&quot;:300,\n     &quot;method&quot;:&quot;aes-256-cfb&quot;,\n     &quot;fast_open&quot;: false\n }\n</code></pre><ul>\n<li><p>修改“server_port”:12345 即可</p>\n</li>\n<li><p>修改登录端口</p>\n<pre><code>cd /etc/ssh\n\n vi sshd_config \n</code></pre></li>\n<li><p>修改sshd_config中的Port端口 这个端口需要和ssh登录的端口一致 如果不一致ssh将会登录不了</p>\n</li>\n</ul>\n<h3 id=\"5-配置完成后-可以添加shadowsocks环境\"><a href=\"#5-配置完成后-可以添加shadowsocks环境\" class=\"headerlink\" title=\"5.配置完成后 可以添加shadowsocks环境\"></a>5.配置完成后 可以添加shadowsocks环境</h3><h4 id=\"在已经登录服务器的情况下-执行\"><a href=\"#在已经登录服务器的情况下-执行\" class=\"headerlink\" title=\" 在已经登录服务器的情况下 执行 \"></a><strong> 在已经登录服务器的情况下 执行 </strong></h4><pre><code>sudo pip install shadowsocks\n</code></pre><p><strong> 在没有/etc/shadowsocks.json配置文件的情况下  </strong></p>\n<pre><code>ssserver -h //查看所有参数\n\n ssserver -p 443 -k password -m aes-256-cfb //前台运行，443为服务器端口，password为密码，修改这两项即可\n\n sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start //后台运行方法，修改同上\n\n sudo ssserver -d stop //停止运行\n\n sudo less /var/log/shadowsocks.log //检查日志\n</code></pre><p><strong> vi /etc/shadowsocks.json </strong></p>\n<pre><code>{\n    &quot;server&quot;:&quot;my_server_ip&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_address&quot;: &quot;127.0.0.1&quot;,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;mypassword&quot;,\n    &quot;timeout&quot;:300,\n    &quot;method&quot;:&quot;aes-256-cfb&quot;,\n    &quot;fast_open&quot;: false\n}\n\n    ssserver -c /etc/shadowsocks.json //前台运行\n\n    ssserver -c /etc/shadowsocks.json -d start //后台运行\n\n    ssserver -c /etc/shadowsocks.json -d stop //停止\n</code></pre><h3 id=\"6-几项检查命令-和一些error\"><a href=\"#6-几项检查命令-和一些error\" class=\"headerlink\" title=\"6 几项检查命令 和一些error\"></a>6 几项检查命令 和一些error</h3><pre><code>netstat -antpl|grep -i listen //查看服务器运行状态\n\n chmod 600 ~/.ssh/authorized_keys //记住要设置文件为可读可写rw\n\n ll ~/.ssh //查看文件的权限\n</code></pre><p> <strong>[Error 98] Address already in use</strong></p>\n<pre><code>这个error应该是端口被占用了 修改shadowsocks.json中的端口\n\n 切记shadowsocks.json中的端口不要和ssh登录端口一样 这是不一样的\n</code></pre><p><strong>Permission denied(publishkey,gssapi-keyex,gssapi-with-mic)</strong></p>\n<pre><code>使用ssh登录服务器报错 这个错误是公钥没有添加在authorized_keys中 \n\n 加进去就行\n</code></pre><h3 id=\"7-如果以上都成功了-还不能翻墙\"><a href=\"#7-如果以上都成功了-还不能翻墙\" class=\"headerlink\" title=\"7 如果以上都成功了 还不能翻墙\"></a>7 如果以上都成功了 还不能翻墙</h3><pre><code>请先检查一下自己是否开启了shadowsocks翻墙了 如果有关掉 然后重试\n 玩的开心\n WTF GFW\n</code></pre><h3 id=\"2017-10-09-更新\"><a href=\"#2017-10-09-更新\" class=\"headerlink\" title=\"2017-10-09 更新\"></a>2017-10-09 更新</h3><p>之前的东京服务器被封了 于是又购买了一个新加坡的 遇到个小坑 CentOS 7 需要开放防火墙 shadowsocks 服务端口，检查 VPS 供应商是设置的 iptables 还是 firewall，我的是 firewall，所以需要添加一条，然后重新加载一下就好了：</p>\n<pre><code>firewall-cmd --permanent --add-port=8388/tcp //8388改成自己设置的端口号\n firewall-cmd --reload\n</code></pre><p>将端口改成自己配置的端口，也就是上面的8388</p>\n<p>最后，启动ShadowSocks服务即可</p>\n<pre><code>ssserver -c /etc/shadowsocks.json -d restart\n</code></pre>","excerpt":"","more":"<blockquote>\n<p> <strong>记住 确认是否已经登录服务器了 以下操作基本都是基于登录状态</strong> </p>\n</blockquote>\n<h3 id=\"1-使用ssh生成秘钥\"><a href=\"#1-使用ssh生成秘钥\" class=\"headerlink\" title=\"1.使用ssh生成秘钥\"></a>1.使用ssh生成秘钥</h3><pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n</code></pre><ul>\n<li>然后会提示输入密钥的名字 比如输入 oktang</li>\n<li>注意要避免重复命名</li>\n<li>还要求输入私钥密码 password</li>\n</ul>\n<h3 id=\"2-配置本地ssh登录-需要修改config文件-添加服务器-用户名和端口信息\"><a href=\"#2-配置本地ssh登录-需要修改config文件-添加服务器-用户名和端口信息\" class=\"headerlink\" title=\"2.配置本地ssh登录 需要修改config文件 添加服务器 用户名和端口信息\"></a>2.配置本地ssh登录 需要修改config文件 添加服务器 用户名和端口信息</h3><pre><code>Host vultr\n     HostName 0.0.0.0 //自己的服务器地址\n     User user  //服务器用户名\n     Port 1080  //连接服务器的端口\n     IdentityFile ~/.ssh/oktang //私钥路径\n</code></pre><h3 id=\"3-将这个公钥oktang-pub添加到服务器上的authorization-keys中\"><a href=\"#3-将这个公钥oktang-pub添加到服务器上的authorization-keys中\" class=\"headerlink\" title=\"3.将这个公钥oktang.pub添加到服务器上的authorization.keys中\"></a>3.将这个公钥<em>oktang.pub</em>添加到服务器上的authorization.keys中</h3><ul>\n<li>authorization.keys这个文件如果没有就新生成一个</li>\n<li><p>使用ssh登录到服务器</p>\n<pre><code>ssh oktang\n cd ~/.ssh\n vi authorized_keys\n</code></pre></li>\n<li><p>将之前生成的公钥内容拷贝到authorized_keys中</p>\n</li>\n<li>ok</li>\n</ul>\n<h3 id=\"4-如果需要修改端口-使用ssh登录服务器\"><a href=\"#4-如果需要修改端口-使用ssh登录服务器\" class=\"headerlink\" title=\"4.如果需要修改端口 使用ssh登录服务器\"></a>4.如果需要修改端口 使用ssh登录服务器</h3><p>修改shadow socks中的端口 或者密码什么的</p>\n<pre><code>vi /etc/shadowsocks.json\n\n单一账号配置\n {\n     &quot;server&quot;:&quot;0.0.0.0”, //这里不用绑定你的服务器\n     &quot;server_port”:port, //这个是shadow socks端口 到时候客户端需要用的\n     &quot;local_address&quot;: &quot;127.0.0.1&quot;,\n     &quot;local_port&quot;:1080,\n     &quot;password”:&quot;password”,//shadowsocks密码\n     &quot;timeout&quot;:300,\n     &quot;method&quot;:&quot;aes-256-cfb&quot;,\n     &quot;fast_open&quot;: false\n }\n\n 多账号配置\n {\n     &quot;server&quot;:&quot;0.0.0.0&quot;, //这里不用绑定你的服务器\n     &quot;local_address&quot;: &quot;127.0.0.1&quot;,\n     &quot;local_port&quot;:1080,\n     &quot;port_password&quot;:{\n        &quot;port1&quot;:&quot;password1&quot;,\n        &quot;port2&quot;:&quot;password2&quot;,\n        &quot;port3&quot;:&quot;password3&quot;\n     },\n     &quot;timeout&quot;:300,\n     &quot;method&quot;:&quot;aes-256-cfb&quot;,\n     &quot;fast_open&quot;: false\n }\n</code></pre><ul>\n<li><p>修改“server_port”:12345 即可</p>\n</li>\n<li><p>修改登录端口</p>\n<pre><code>cd /etc/ssh\n\n vi sshd_config \n</code></pre></li>\n<li><p>修改sshd_config中的Port端口 这个端口需要和ssh登录的端口一致 如果不一致ssh将会登录不了</p>\n</li>\n</ul>\n<h3 id=\"5-配置完成后-可以添加shadowsocks环境\"><a href=\"#5-配置完成后-可以添加shadowsocks环境\" class=\"headerlink\" title=\"5.配置完成后 可以添加shadowsocks环境\"></a>5.配置完成后 可以添加shadowsocks环境</h3><h4 id=\"在已经登录服务器的情况下-执行\"><a href=\"#在已经登录服务器的情况下-执行\" class=\"headerlink\" title=\" 在已经登录服务器的情况下 执行 \"></a><strong> 在已经登录服务器的情况下 执行 </strong></h4><pre><code>sudo pip install shadowsocks\n</code></pre><p><strong> 在没有/etc/shadowsocks.json配置文件的情况下  </strong></p>\n<pre><code>ssserver -h //查看所有参数\n\n ssserver -p 443 -k password -m aes-256-cfb //前台运行，443为服务器端口，password为密码，修改这两项即可\n\n sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start //后台运行方法，修改同上\n\n sudo ssserver -d stop //停止运行\n\n sudo less /var/log/shadowsocks.log //检查日志\n</code></pre><p><strong> vi /etc/shadowsocks.json </strong></p>\n<pre><code>{\n    &quot;server&quot;:&quot;my_server_ip&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_address&quot;: &quot;127.0.0.1&quot;,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;mypassword&quot;,\n    &quot;timeout&quot;:300,\n    &quot;method&quot;:&quot;aes-256-cfb&quot;,\n    &quot;fast_open&quot;: false\n}\n\n    ssserver -c /etc/shadowsocks.json //前台运行\n\n    ssserver -c /etc/shadowsocks.json -d start //后台运行\n\n    ssserver -c /etc/shadowsocks.json -d stop //停止\n</code></pre><h3 id=\"6-几项检查命令-和一些error\"><a href=\"#6-几项检查命令-和一些error\" class=\"headerlink\" title=\"6 几项检查命令 和一些error\"></a>6 几项检查命令 和一些error</h3><pre><code>netstat -antpl|grep -i listen //查看服务器运行状态\n\n chmod 600 ~/.ssh/authorized_keys //记住要设置文件为可读可写rw\n\n ll ~/.ssh //查看文件的权限\n</code></pre><p> <strong>[Error 98] Address already in use</strong></p>\n<pre><code>这个error应该是端口被占用了 修改shadowsocks.json中的端口\n\n 切记shadowsocks.json中的端口不要和ssh登录端口一样 这是不一样的\n</code></pre><p><strong>Permission denied(publishkey,gssapi-keyex,gssapi-with-mic)</strong></p>\n<pre><code>使用ssh登录服务器报错 这个错误是公钥没有添加在authorized_keys中 \n\n 加进去就行\n</code></pre><h3 id=\"7-如果以上都成功了-还不能翻墙\"><a href=\"#7-如果以上都成功了-还不能翻墙\" class=\"headerlink\" title=\"7 如果以上都成功了 还不能翻墙\"></a>7 如果以上都成功了 还不能翻墙</h3><pre><code>请先检查一下自己是否开启了shadowsocks翻墙了 如果有关掉 然后重试\n 玩的开心\n WTF GFW\n</code></pre><h3 id=\"2017-10-09-更新\"><a href=\"#2017-10-09-更新\" class=\"headerlink\" title=\"2017-10-09 更新\"></a>2017-10-09 更新</h3><p>之前的东京服务器被封了 于是又购买了一个新加坡的 遇到个小坑 CentOS 7 需要开放防火墙 shadowsocks 服务端口，检查 VPS 供应商是设置的 iptables 还是 firewall，我的是 firewall，所以需要添加一条，然后重新加载一下就好了：</p>\n<pre><code>firewall-cmd --permanent --add-port=8388/tcp //8388改成自己设置的端口号\n firewall-cmd --reload\n</code></pre><p>将端口改成自己配置的端口，也就是上面的8388</p>\n<p>最后，启动ShadowSocks服务即可</p>\n<pre><code>ssserver -c /etc/shadowsocks.json -d restart\n</code></pre>"},{"title":"配置Jenkins for iOS 记录一些问题点","date":"2016-09-26T09:24:46.000Z","_content":"\n## 1 源码管理\n\n*  Git源码管理问题\t\n\n\t\tRepository URL\t添加完git地址之后需要再添加一个ssh的私钥\n\t\n*  超时问题：\n\n\t\t 将Timeout (in minutes) for clone and fetch operations噶为60 默认为10 如果项目大的话可能会超时\n\n![](/images/sourceManager.png)\n\n\n## 2 构建触发器\n\n* 这一步比较简单 按固定格式填写就行\n\n\t\t比如：\n\t\t Build periodically H 20 * * *\n\t\t Poll SCM H/5 * * * *\n\n![](/images/BuildTrigger.png)\t\t\n\t\t\n\t\t\n## 3 构建环境\n\n   * 这个需要配置证书和描述文件 以及输出路径  配置证书这部分就不细说了 网上很多资料\n   \n![](/images/BuildEnv.png)\t\n\n* [手把手教你利用Jenkins持续集成iOS项目](http://www.jianshu.com/p/41ecb06ae95f)\n\n* [CI第一篇:Jenkins+github->fir.im/蒲公英pgyer.com](http://www.jianshu.com/p/a501153c9d59)\n\n* [CI第二篇 集成项目(SVN)workspace编译生成ipa到fir-蒲公英(jenkins)](http://www.jianshu.com/p/12e445c0d4ee)\n\n* [Jenkins+GitHub+Xcode+fir搭了一个持续集成环境](http://www.jianshu.com/p/a17167274463)\n\n\t\n## 4 构建\n\t\n* 有一个小坑 \n\n\t针对非cocoapods项目 就是如果你的项目结构比较复杂 在build的时候可能会出现error\n\t\n\t\txcodebuild: error: '/Users/Shared/Jenkins/Home/jobs/Jiuai/workspace/YouXian/YouXian' is not a project file.\n\t\t\n\t这个问题是由于你\tXcode Project File 这个选项没有指定xcodeproj导致的 将Xcode Project File设置成你的xcodeproj文件路径\n\t\n\t\t${WORKSPACE}/YouXian/YouXian.xcodeproj\n\t\n![](/images/Advanced Xcode build options.png)\n\n\t\n## 5 构建后操作\n\n* 生成ipa之后可以利用fir或者pgyer上传 填好Token就行了\n* 要是有能力写脚本也行\n\n\n## 6 The following build commands failed: Check dependencies\n\n\t\n* Jenkins 集成Xcode 项目的时候在证书上遇到了问题\n\t\n\t    Check dependencies\n\t\t Code Sign error: No codesigning identities found: No codesigning identities (i.e. certificate and private key pairs) \t\t that \t\n\t\t match the provisioning profile specified in your build settings (“qingyunDeveloper”) were found.\n\n* 如果遇到类似的错误 解决办法：\n\n\t\t1 打开keychain keys 找到apple 的开发者证书。然后复制。 \n\t\t 2 选择左边的系统（system）把刚复制的证书放进去。\n\t\t\n* 如果这个还没有解决 接下来第二步：\n\n\t\t1 找到你用户下的Provisioning Profiles 文件。目录为 /Users/xxx/Library/MobileDevice/Provisioning Profiles  \n\t\t xxx表示你自己的用户名\n\t\t 2 把这里面所有的证书复制到/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profile 这个文件夹下\n\n\n* 最后提示\n\t\t\n\t\tiPhone.build/ProjectCos.xcent /Users/chenqing/Sqy/iOSProject/cyou/Svn/Cos/CosXCode_lxh/build/ProjectCos.app\n\n\t\t ** BUILD SUCCEEDED **\n\n\t\t Finished: SUCCESS\n\t\n\t[链接： Jenkins Xcode 证书设置错误 Code Sign error: No matching codesigning identity found: No codesigning identities\n](http://www.cnblogs.com/qingjoin/p/3929493.html)\n\n\n## 7 注意点\n\n* 关于证书问题还有一个注意点 \n\t\t\n\t\t如果你是一个测试项目 \n\t\t 在本地配置好证书和描述文件后一定要上传到github或者服务器上 \n\t\t 然后在进行构建 否则肯定会构建失败的  \n\t\t 因为jenkins是拉取你远端代码仓库的最新代码 \n\t\t 如果只在本地配置不上传 必然构建失败 \n\t\t 这也是一个比较基础的问题 \n\n\t","source":"_posts/配置Jenkins-for-iOS-记录一些问题点.md","raw":"---\ntitle: 配置Jenkins for iOS 记录一些问题点\ndate: 2016-09-26 17:24:46\ntags: Jenkins\n---\n\n## 1 源码管理\n\n*  Git源码管理问题\t\n\n\t\tRepository URL\t添加完git地址之后需要再添加一个ssh的私钥\n\t\n*  超时问题：\n\n\t\t 将Timeout (in minutes) for clone and fetch operations噶为60 默认为10 如果项目大的话可能会超时\n\n![](/images/sourceManager.png)\n\n\n## 2 构建触发器\n\n* 这一步比较简单 按固定格式填写就行\n\n\t\t比如：\n\t\t Build periodically H 20 * * *\n\t\t Poll SCM H/5 * * * *\n\n![](/images/BuildTrigger.png)\t\t\n\t\t\n\t\t\n## 3 构建环境\n\n   * 这个需要配置证书和描述文件 以及输出路径  配置证书这部分就不细说了 网上很多资料\n   \n![](/images/BuildEnv.png)\t\n\n* [手把手教你利用Jenkins持续集成iOS项目](http://www.jianshu.com/p/41ecb06ae95f)\n\n* [CI第一篇:Jenkins+github->fir.im/蒲公英pgyer.com](http://www.jianshu.com/p/a501153c9d59)\n\n* [CI第二篇 集成项目(SVN)workspace编译生成ipa到fir-蒲公英(jenkins)](http://www.jianshu.com/p/12e445c0d4ee)\n\n* [Jenkins+GitHub+Xcode+fir搭了一个持续集成环境](http://www.jianshu.com/p/a17167274463)\n\n\t\n## 4 构建\n\t\n* 有一个小坑 \n\n\t针对非cocoapods项目 就是如果你的项目结构比较复杂 在build的时候可能会出现error\n\t\n\t\txcodebuild: error: '/Users/Shared/Jenkins/Home/jobs/Jiuai/workspace/YouXian/YouXian' is not a project file.\n\t\t\n\t这个问题是由于你\tXcode Project File 这个选项没有指定xcodeproj导致的 将Xcode Project File设置成你的xcodeproj文件路径\n\t\n\t\t${WORKSPACE}/YouXian/YouXian.xcodeproj\n\t\n![](/images/Advanced Xcode build options.png)\n\n\t\n## 5 构建后操作\n\n* 生成ipa之后可以利用fir或者pgyer上传 填好Token就行了\n* 要是有能力写脚本也行\n\n\n## 6 The following build commands failed: Check dependencies\n\n\t\n* Jenkins 集成Xcode 项目的时候在证书上遇到了问题\n\t\n\t    Check dependencies\n\t\t Code Sign error: No codesigning identities found: No codesigning identities (i.e. certificate and private key pairs) \t\t that \t\n\t\t match the provisioning profile specified in your build settings (“qingyunDeveloper”) were found.\n\n* 如果遇到类似的错误 解决办法：\n\n\t\t1 打开keychain keys 找到apple 的开发者证书。然后复制。 \n\t\t 2 选择左边的系统（system）把刚复制的证书放进去。\n\t\t\n* 如果这个还没有解决 接下来第二步：\n\n\t\t1 找到你用户下的Provisioning Profiles 文件。目录为 /Users/xxx/Library/MobileDevice/Provisioning Profiles  \n\t\t xxx表示你自己的用户名\n\t\t 2 把这里面所有的证书复制到/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profile 这个文件夹下\n\n\n* 最后提示\n\t\t\n\t\tiPhone.build/ProjectCos.xcent /Users/chenqing/Sqy/iOSProject/cyou/Svn/Cos/CosXCode_lxh/build/ProjectCos.app\n\n\t\t ** BUILD SUCCEEDED **\n\n\t\t Finished: SUCCESS\n\t\n\t[链接： Jenkins Xcode 证书设置错误 Code Sign error: No matching codesigning identity found: No codesigning identities\n](http://www.cnblogs.com/qingjoin/p/3929493.html)\n\n\n## 7 注意点\n\n* 关于证书问题还有一个注意点 \n\t\t\n\t\t如果你是一个测试项目 \n\t\t 在本地配置好证书和描述文件后一定要上传到github或者服务器上 \n\t\t 然后在进行构建 否则肯定会构建失败的  \n\t\t 因为jenkins是拉取你远端代码仓库的最新代码 \n\t\t 如果只在本地配置不上传 必然构建失败 \n\t\t 这也是一个比较基础的问题 \n\n\t","slug":"配置Jenkins-for-iOS-记录一些问题点","published":1,"updated":"2019-08-14T13:31:03.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzbbi8i80005aq1kgg2o96jw","content":"<h2 id=\"1-源码管理\"><a href=\"#1-源码管理\" class=\"headerlink\" title=\"1 源码管理\"></a>1 源码管理</h2><ul>\n<li><p>Git源码管理问题    </p>\n<pre><code>Repository URL    添加完git地址之后需要再添加一个ssh的私钥\n</code></pre></li>\n<li><p>超时问题：</p>\n<pre><code>将Timeout (in minutes) for clone and fetch operations噶为60 默认为10 如果项目大的话可能会超时\n</code></pre></li>\n</ul>\n<p><img src=\"/images/sourceManager.png\" alt=\"\"></p>\n<h2 id=\"2-构建触发器\"><a href=\"#2-构建触发器\" class=\"headerlink\" title=\"2 构建触发器\"></a>2 构建触发器</h2><ul>\n<li><p>这一步比较简单 按固定格式填写就行</p>\n<pre><code>比如：\n Build periodically H 20 * * *\n Poll SCM H/5 * * * *\n</code></pre></li>\n</ul>\n<p><img src=\"/images/BuildTrigger.png\" alt=\"\">        </p>\n<h2 id=\"3-构建环境\"><a href=\"#3-构建环境\" class=\"headerlink\" title=\"3 构建环境\"></a>3 构建环境</h2><ul>\n<li>这个需要配置证书和描述文件 以及输出路径  配置证书这部分就不细说了 网上很多资料</li>\n</ul>\n<p><img src=\"/images/BuildEnv.png\" alt=\"\">    </p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/41ecb06ae95f\" target=\"_blank\" rel=\"external\">手把手教你利用Jenkins持续集成iOS项目</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/a501153c9d59\" target=\"_blank\" rel=\"external\">CI第一篇:Jenkins+github-&gt;fir.im/蒲公英pgyer.com</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/12e445c0d4ee\" target=\"_blank\" rel=\"external\">CI第二篇 集成项目(SVN)workspace编译生成ipa到fir-蒲公英(jenkins)</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/a17167274463\" target=\"_blank\" rel=\"external\">Jenkins+GitHub+Xcode+fir搭了一个持续集成环境</a></p>\n</li>\n</ul>\n<h2 id=\"4-构建\"><a href=\"#4-构建\" class=\"headerlink\" title=\"4 构建\"></a>4 构建</h2><ul>\n<li><p>有一个小坑 </p>\n<p>  针对非cocoapods项目 就是如果你的项目结构比较复杂 在build的时候可能会出现error</p>\n<pre><code>xcodebuild: error: &apos;/Users/Shared/Jenkins/Home/jobs/Jiuai/workspace/YouXian/YouXian&apos; is not a project file.\n</code></pre><p>  这个问题是由于你    Xcode Project File 这个选项没有指定xcodeproj导致的 将Xcode Project File设置成你的xcodeproj文件路径</p>\n<pre><code>${WORKSPACE}/YouXian/YouXian.xcodeproj\n</code></pre></li>\n</ul>\n<p><img src=\"/images/Advanced Xcode build options.png\" alt=\"\"></p>\n<h2 id=\"5-构建后操作\"><a href=\"#5-构建后操作\" class=\"headerlink\" title=\"5 构建后操作\"></a>5 构建后操作</h2><ul>\n<li>生成ipa之后可以利用fir或者pgyer上传 填好Token就行了</li>\n<li>要是有能力写脚本也行</li>\n</ul>\n<h2 id=\"6-The-following-build-commands-failed-Check-dependencies\"><a href=\"#6-The-following-build-commands-failed-Check-dependencies\" class=\"headerlink\" title=\"6 The following build commands failed: Check dependencies\"></a>6 The following build commands failed: Check dependencies</h2><ul>\n<li><p>Jenkins 集成Xcode 项目的时候在证书上遇到了问题</p>\n<pre><code>Check dependencies\n Code Sign error: No codesigning identities found: No codesigning identities (i.e. certificate and private key pairs)          that     \n match the provisioning profile specified in your build settings (“qingyunDeveloper”) were found.\n</code></pre></li>\n<li><p>如果遇到类似的错误 解决办法：</p>\n<pre><code>1 打开keychain keys 找到apple 的开发者证书。然后复制。 \n 2 选择左边的系统（system）把刚复制的证书放进去。\n</code></pre></li>\n<li><p>如果这个还没有解决 接下来第二步：</p>\n<pre><code>1 找到你用户下的Provisioning Profiles 文件。目录为 /Users/xxx/Library/MobileDevice/Provisioning Profiles  \n xxx表示你自己的用户名\n 2 把这里面所有的证书复制到/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profile 这个文件夹下\n</code></pre></li>\n</ul>\n<ul>\n<li><p>最后提示</p>\n<pre><code>iPhone.build/ProjectCos.xcent /Users/chenqing/Sqy/iOSProject/cyou/Svn/Cos/CosXCode_lxh/build/ProjectCos.app\n\n ** BUILD SUCCEEDED **\n\n Finished: SUCCESS\n</code></pre><p>  <a href=\"http://www.cnblogs.com/qingjoin/p/3929493.html\" target=\"_blank\" rel=\"external\">链接： Jenkins Xcode 证书设置错误 Code Sign error: No matching codesigning identity found: No codesigning identities\n</a></p>\n</li>\n</ul>\n<h2 id=\"7-注意点\"><a href=\"#7-注意点\" class=\"headerlink\" title=\"7 注意点\"></a>7 注意点</h2><ul>\n<li><p>关于证书问题还有一个注意点 </p>\n<pre><code>如果你是一个测试项目 \n 在本地配置好证书和描述文件后一定要上传到github或者服务器上 \n 然后在进行构建 否则肯定会构建失败的  \n 因为jenkins是拉取你远端代码仓库的最新代码 \n 如果只在本地配置不上传 必然构建失败 \n 这也是一个比较基础的问题 \n</code></pre></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"1-源码管理\"><a href=\"#1-源码管理\" class=\"headerlink\" title=\"1 源码管理\"></a>1 源码管理</h2><ul>\n<li><p>Git源码管理问题    </p>\n<pre><code>Repository URL    添加完git地址之后需要再添加一个ssh的私钥\n</code></pre></li>\n<li><p>超时问题：</p>\n<pre><code>将Timeout (in minutes) for clone and fetch operations噶为60 默认为10 如果项目大的话可能会超时\n</code></pre></li>\n</ul>\n<p><img src=\"/images/sourceManager.png\" alt=\"\"></p>\n<h2 id=\"2-构建触发器\"><a href=\"#2-构建触发器\" class=\"headerlink\" title=\"2 构建触发器\"></a>2 构建触发器</h2><ul>\n<li><p>这一步比较简单 按固定格式填写就行</p>\n<pre><code>比如：\n Build periodically H 20 * * *\n Poll SCM H/5 * * * *\n</code></pre></li>\n</ul>\n<p><img src=\"/images/BuildTrigger.png\" alt=\"\">        </p>\n<h2 id=\"3-构建环境\"><a href=\"#3-构建环境\" class=\"headerlink\" title=\"3 构建环境\"></a>3 构建环境</h2><ul>\n<li>这个需要配置证书和描述文件 以及输出路径  配置证书这部分就不细说了 网上很多资料</li>\n</ul>\n<p><img src=\"/images/BuildEnv.png\" alt=\"\">    </p>\n<ul>\n<li><p><a href=\"http://www.jianshu.com/p/41ecb06ae95f\">手把手教你利用Jenkins持续集成iOS项目</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/a501153c9d59\">CI第一篇:Jenkins+github-&gt;fir.im/蒲公英pgyer.com</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/12e445c0d4ee\">CI第二篇 集成项目(SVN)workspace编译生成ipa到fir-蒲公英(jenkins)</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/a17167274463\">Jenkins+GitHub+Xcode+fir搭了一个持续集成环境</a></p>\n</li>\n</ul>\n<h2 id=\"4-构建\"><a href=\"#4-构建\" class=\"headerlink\" title=\"4 构建\"></a>4 构建</h2><ul>\n<li><p>有一个小坑 </p>\n<p>  针对非cocoapods项目 就是如果你的项目结构比较复杂 在build的时候可能会出现error</p>\n<pre><code>xcodebuild: error: &apos;/Users/Shared/Jenkins/Home/jobs/Jiuai/workspace/YouXian/YouXian&apos; is not a project file.\n</code></pre><p>  这个问题是由于你    Xcode Project File 这个选项没有指定xcodeproj导致的 将Xcode Project File设置成你的xcodeproj文件路径</p>\n<pre><code>${WORKSPACE}/YouXian/YouXian.xcodeproj\n</code></pre></li>\n</ul>\n<p><img src=\"/images/Advanced Xcode build options.png\" alt=\"\"></p>\n<h2 id=\"5-构建后操作\"><a href=\"#5-构建后操作\" class=\"headerlink\" title=\"5 构建后操作\"></a>5 构建后操作</h2><ul>\n<li>生成ipa之后可以利用fir或者pgyer上传 填好Token就行了</li>\n<li>要是有能力写脚本也行</li>\n</ul>\n<h2 id=\"6-The-following-build-commands-failed-Check-dependencies\"><a href=\"#6-The-following-build-commands-failed-Check-dependencies\" class=\"headerlink\" title=\"6 The following build commands failed: Check dependencies\"></a>6 The following build commands failed: Check dependencies</h2><ul>\n<li><p>Jenkins 集成Xcode 项目的时候在证书上遇到了问题</p>\n<pre><code>Check dependencies\n Code Sign error: No codesigning identities found: No codesigning identities (i.e. certificate and private key pairs)          that     \n match the provisioning profile specified in your build settings (“qingyunDeveloper”) were found.\n</code></pre></li>\n<li><p>如果遇到类似的错误 解决办法：</p>\n<pre><code>1 打开keychain keys 找到apple 的开发者证书。然后复制。 \n 2 选择左边的系统（system）把刚复制的证书放进去。\n</code></pre></li>\n<li><p>如果这个还没有解决 接下来第二步：</p>\n<pre><code>1 找到你用户下的Provisioning Profiles 文件。目录为 /Users/xxx/Library/MobileDevice/Provisioning Profiles  \n xxx表示你自己的用户名\n 2 把这里面所有的证书复制到/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profile 这个文件夹下\n</code></pre></li>\n</ul>\n<ul>\n<li><p>最后提示</p>\n<pre><code>iPhone.build/ProjectCos.xcent /Users/chenqing/Sqy/iOSProject/cyou/Svn/Cos/CosXCode_lxh/build/ProjectCos.app\n\n ** BUILD SUCCEEDED **\n\n Finished: SUCCESS\n</code></pre><p>  <a href=\"http://www.cnblogs.com/qingjoin/p/3929493.html\">链接： Jenkins Xcode 证书设置错误 Code Sign error: No matching codesigning identity found: No codesigning identities\n</a></p>\n</li>\n</ul>\n<h2 id=\"7-注意点\"><a href=\"#7-注意点\" class=\"headerlink\" title=\"7 注意点\"></a>7 注意点</h2><ul>\n<li><p>关于证书问题还有一个注意点 </p>\n<pre><code>如果你是一个测试项目 \n 在本地配置好证书和描述文件后一定要上传到github或者服务器上 \n 然后在进行构建 否则肯定会构建失败的  \n 因为jenkins是拉取你远端代码仓库的最新代码 \n 如果只在本地配置不上传 必然构建失败 \n 这也是一个比较基础的问题 \n</code></pre></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjzbbi8hz0000aq1kqlaj395s","tag_id":"cjzbbi8i40002aq1kwlqgqfy6","_id":"cjzbbi8i90007aq1khtcqj36y"},{"post_id":"cjzbbi8i70004aq1ke3iwdapo","tag_id":"cjzbbi8i90006aq1kgewojwd8","_id":"cjzbbi8ia0009aq1kpymdnv14"},{"post_id":"cjzbbi8i80005aq1kgg2o96jw","tag_id":"cjzbbi8i90008aq1ko6lo7odu","_id":"cjzbbi8ia000aaq1keaq2tcu7"}],"Tag":[{"name":"Hexo","_id":"cjzbbi8i40002aq1kwlqgqfy6"},{"name":"shadowsocks","_id":"cjzbbi8i90006aq1kgewojwd8"},{"name":"Jenkins","_id":"cjzbbi8i90008aq1ko6lo7odu"}]}}